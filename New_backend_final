// =====================================================================================
// dto/ValueDiff.java
// ==========‚âà==========================================================================

package com.tcs.fincore.CommonRequestService.dto;

import lombok.*;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ValueDiff {
    private Object oldValue;
    private Object newValue;
}





// =====================================================================================
// dto/TemplateDiffResponseDto.java
// ==========‚âà==========================================================================


package com.tcs.fincore.CommonRequestService.dto;

import lombok.*;

import java.util.Map;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TemplateDiffResponseDto {

    private ReportTemplateDto oldTemplate;
    private ReportTemplateDto newTemplate;

    /**
     * cellId -> (fieldName -> old/new value)
     */
    private Map<String, Map<String, ValueDiff>> cellDiffs;
    private Map<String, Map<String, ValueDiff>> columnDiffs;
}





// =====================================================================================
// controller 
// ==========‚âà==========================================================================


    private final TemplateDiffService templateDiffService;

    @PostMapping("/template-diff")
    public TemplateDiffResponseDto compareTemplates(
            @RequestBody TemplateDiffRequest request
    ) {
        return templateDiffService.compareByRequestId(request.getRequestId());
    }

    @Data
    public static class TemplateDiffRequest {
        private Long requestId;
    }

}






// =====================================================================================
// service/TemplateDiffService.java
// ==========‚âà==========================================================================



package com.tcs.fincore.CommonRequestService.service;

import com.tcs.fincore.CommonRequestService.dto.ReportTemplateDto;
import com.tcs.fincore.CommonRequestService.dto.TemplateDiffResponseDto;

public interface TemplateDiffService {

    TemplateDiffResponseDto compare(
            ReportTemplateDto oldTemplate,
            ReportTemplateDto newTemplate
    );
}







// =====================================================================================
// service/TemplateDiffServiceImpl.java
// ==========‚âà==========================================================================





package com.tcs.fincore.CommonRequestService.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.tcs.fincore.CommonRequestService.dto.*;
import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.repository.CommonRequestRepository;
import com.tcs.fincore.CommonRequestService.repository.ReportTemplateRepository;
import com.tcs.fincore.CommonRequestService.util.JsonCompareUtil;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
@RequiredArgsConstructor
public class TemplateDiffServiceImpl implements TemplateDiffService {

    private final CommonRequestRepository commonRequestRepository;
    private final ReportTemplateRepository reportTemplateRepository;
    private final JsonCompareUtil jsonCompareUtil;
    private final ObjectMapper objectMapper;

    @Override
    public TemplateDiffResponseDto compareByRequestId(Long requestId) {

        CommonReq req = commonRequestRepository.findById(requestId)
                .orElseThrow(() -> new IllegalArgumentException("Request not found"));

        ReportTemplateDto newTemplate;
        try {
            newTemplate = objectMapper.readValue(req.getPayload(), ReportTemplateDto.class);
        } catch (Exception e) {
            throw new IllegalStateException("Invalid request payload JSON", e);
        }

        String reportId = newTemplate.getTemplate().getReportMeta().getReportId();

        String oldJson = reportTemplateRepository
                .findFirstByReportIdAndStatus(reportId, "ACTIVE")
                .orElseThrow(() -> new IllegalStateException("Active template not found"))
                .getTemplateJson(); // ‚úèÔ∏è CHANGED (must read JSON column)

        ReportTemplateDto oldTemplate;
        try {
            oldTemplate = objectMapper.readValue(oldJson, ReportTemplateDto.class);
        } catch (Exception e) {
            throw new IllegalStateException("Invalid stored template JSON", e);
        }

        Map<String, Map<String, ValueDiff>> cellDiffs =
                jsonCompareUtil.compareTemplates(oldTemplate, newTemplate);

        Map<String, Map<String, ValueDiff>> columnDiffs =   // üî¥ NEW
                jsonCompareUtil.compareColumnFormats(oldTemplate, newTemplate);

        return TemplateDiffResponseDto.builder()
                .oldTemplate(oldTemplate)
                .newTemplate(newTemplate)
                .cellDiffs(cellDiffs)
                .columnDiffs(columnDiffs) // üî¥ NEW
                .build();
    }
}




// =====================================================================================
// util/JsonCompareUtil.java
// ==========‚âà==========================================================================

package com.tcs.fincore.CommonRequestService.util;

import com.tcs.fincore.CommonRequestService.dto.ReportTemplateDto;
import com.tcs.fincore.CommonRequestService.dto.ValueDiff;
import org.springframework.stereotype.Component;

import java.util.*;

@Component
public class JsonCompareUtil {

    /**
     * rowId -> cellId -> fieldName -> ValueDiff
     */
    public Map<String, Map<String, Map<String, ValueDiff>>> compareTemplates(
            ReportTemplateDto oldTemplate,
            ReportTemplateDto newTemplate
    ) {

        Map<String, Map<String, Map<String, ValueDiff>>> diffs = new LinkedHashMap<>();

        if (oldTemplate == null || newTemplate == null) {
            return diffs;
        }

        // 1Ô∏è‚É£ Compare COLUMN FORMAT changes (important fix)
        compareColumnFormats(
                oldTemplate.getTemplate().getReportData().getColumns(),
                newTemplate.getTemplate().getReportData().getColumns(),
                diffs
        );

        // 2Ô∏è‚É£ Compare ROW + CELL level changes
        Map<String, ReportTemplateDto.Row> oldRows = mapRows(oldTemplate);
        Map<String, ReportTemplateDto.Row> newRows = mapRows(newTemplate);

        for (String rowId : newRows.keySet()) {
            ReportTemplateDto.Row newRow = newRows.get(rowId);
            ReportTemplateDto.Row oldRow = oldRows.get(rowId);

            if (oldRow == null) {
                continue;
            }

            Map<String, ReportTemplateDto.Cell> oldCells = mapCells(oldRow);
            Map<String, ReportTemplateDto.Cell> newCells = mapCells(newRow);

            for (String cellId : newCells.keySet()) {
                ReportTemplateDto.Cell newCell = newCells.get(cellId);
                ReportTemplateDto.Cell oldCell = oldCells.get(cellId);

                if (oldCell == null) {
                    continue;
                }

                compareCell(rowId, cellId, oldCell, newCell, diffs);
            }
        }

        return diffs;
    }

    // ---------------- HELPERS ----------------

    private void compareCell(
            String rowId,
            String cellId,
            ReportTemplateDto.Cell oldCell,
            ReportTemplateDto.Cell newCell,
            Map<String, Map<String, Map<String, ValueDiff>>> diffs
    ) {

        compareField(rowId, cellId, "value", oldCell.getValue(), newCell.getValue(), diffs);
        compareField(rowId, cellId, "expression", oldCell.getExpression(), newCell.getExpression(), diffs);
        compareField(rowId, cellId, "variables", oldCell.getVariables(), newCell.getVariables(), diffs);
        compareField(rowId, cellId, "source", oldCell.getSource(), newCell.getSource(), diffs);
        compareField(rowId, cellId, "render", oldCell.getRender(), newCell.getRender(), diffs);
    }

    private void compareColumnFormats(
            List<ReportTemplateDto.ColumnDefinition> oldCols,
            List<ReportTemplateDto.ColumnDefinition> newCols,
            Map<String, Map<String, Map<String, ValueDiff>>> diffs
    ) {

        Map<String, ReportTemplateDto.ColumnDefinition> oldMap = new LinkedHashMap<>();
        for (ReportTemplateDto.ColumnDefinition c : oldCols) {
            oldMap.put(c.getId(), c);
        }

        for (ReportTemplateDto.ColumnDefinition newCol : newCols) {
            ReportTemplateDto.ColumnDefinition oldCol = oldMap.get(newCol.getId());
            if (oldCol == null) continue;

            if (!Objects.equals(oldCol.getFormat(), newCol.getFormat())) {
                // virtual row + cell to mark column-level change
                compareField(
                        "COLUMN",
                        newCol.getId(),
                        "format",
                        oldCol.getFormat(),
                        newCol.getFormat(),
                        diffs
                );
            }
        }
    }

    private void compareField(
            String rowId,
            String cellId,
            String field,
            Object oldVal,
            Object newVal,
            Map<String, Map<String, Map<String, ValueDiff>>> diffs
    ) {
        if (!Objects.equals(oldVal, newVal)) {
            diffs
                .computeIfAbsent(rowId, r -> new LinkedHashMap<>())
                .computeIfAbsent(cellId, c -> new LinkedHashMap<>())
                .put(field, new ValueDiff(oldVal, newVal));
        }
    }

    private Map<String, ReportTemplateDto.Row> mapRows(ReportTemplateDto template) {
        Map<String, ReportTemplateDto.Row> map = new LinkedHashMap<>();
        for (ReportTemplateDto.Row r : template.getTemplate().getReportData().getRows()) {
            map.put(r.getId(), r);
        }
        return map;
    }

    private Map<String, ReportTemplateDto.Cell> mapCells(ReportTemplateDto.Row row) {
        Map<String, ReportTemplateDto.Cell> map = new LinkedHashMap<>();
        for (ReportTemplateDto.Cell c : row.getCells()) {
            map.put(c.getId(), c);
        }
        return map;
    }
}

