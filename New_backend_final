// =====================================================================================
// dto/ValueDiff.java
// ==========‚âà==========================================================================

package com.tcs.fincore.CommonRequestService.dto;

import lombok.*;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ValueDiff {
    private Object oldValue;
    private Object newValue;
}





// =====================================================================================
// dto/TemplateDiffResponseDto.java
// ==========‚âà==========================================================================


package com.tcs.fincore.CommonRequestService.dto;

import lombok.*;

import java.util.Map;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TemplateDiffResponseDto {

    private ReportTemplateDto oldTemplate;
    private ReportTemplateDto newTemplate;

    /**
     * cellId -> (fieldName -> old/new value)
     */
    private Map<String, Map<String, ValueDiff>> cellDiffs;
}





// =====================================================================================
// controller 
// ==========‚âà==========================================================================



package com.tcs.fincore.CommonRequestService.controller;

import java.util.List;
import java.util.Map;

import com.tcs.fincore.CommonRequestService.dto.*;
import com.tcs.fincore.CommonRequestService.service.TemplateDiffService;
import jakarta.validation.ValidationException;
import lombok.Data;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fincore.commonutilities.jwt.JwtUtil;
import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.service.RequestService;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * RequestController :-
 *
 * This controller handles API requests related to creating, retrieving, and processing common requests within the FinCore Application.
 * It provides endpoints for users to manage their requests, view pending items, and for approvers to update request statuses.
 *
 * @author Shubhankar [v1018405]
 * @version 1.0
 * @since 2025-10-01
 */
@RestController
@RequiredArgsConstructor
@Slf4j
@RequestMapping("/api")
public class RequestController {

	private final RequestService requestService;
    private final JwtUtil jwtUtil;


    /**
     * Creates a new request initiated by a user (maker).
     *
     * @param createRequestDto The data transfer object containing the details of the new request.
     * @param token The authorization token used to identify the user making the request.
     * @return The created CommonReq entity.
     * @throws JsonProcessingException If there is an issue processing the request data.
     */
	@PostMapping("/create-request")
	@ResponseStatus(HttpStatus.CREATED)
	public CommonReq createRequest(
			@Valid @RequestBody CreateRequestDto createRequestDto,
			@RequestHeader("Authorization") String token
	) throws JsonProcessingException {
		String userId = jwtUtil.getUserIdFromToken(token);
		log.info("Received request creation call from user: {}", userId);
		return requestService.createRequest(createRequestDto, userId, token);
	}

    /**
     * Fetches requests created by the current user (maker). Requests can be filtered by `requestType`.
     *
     * @param token The authorization token of the user.
     * @param filterDto An object that may contain a `requestType` for filtering (e.g., `{"requestType": "SEGMENT_CODE"}`).
     * @return A list of CommonReq entities matching the criteria.
     */
	// tab2 master screen
	@PostMapping("/my-requests")
	public List<CommonReq> getMyRequests(
			@RequestHeader("Authorization") String token,
			@RequestBody MyRequestFilterDto filterDto
	) {
		String userId = jwtUtil.getUserIdFromToken(token);
		log.info(
				"Received request for fetch data for the user: {} and request type: {}", userId,
				filterDto.getRequestType()
		);
		return requestService.getMyRequests(userId, filterDto.getRequestType());
	}

    /**
     * Retrieves a list of requests that are pending approval for the current user (excluding the own requests).
     *
     * @param authorizationHeader The authorization token of the user.
     * @param filterDto An object that contain a `requestType` for filtering pending requests.
     * @return A list of pending CommonReq entities excluding the own requests.
     */
	// accept
	@PostMapping("/pending-requests")
	public List<CommonReq> getPendingRequests(
			@RequestHeader("Authorization") String authorizationHeader,
			@RequestBody MyRequestFilterDto filterDto
	) {
		String userId = jwtUtil.getUserIdFromToken(authorizationHeader);
		log.info("Received request for pending data for the request type: {}", filterDto.getRequestType());
		return requestService.getPendingRequests(userId, filterDto.getRequestType());
	}

    /**
     * Retrieves all requests present in the system (intended for admin/supervisory roles).
     *
     * @param authorizationHeader The authorization token.
     * @return A list of all CommonReq entities.
     */
	@GetMapping("/all-requests")
	public List<CommonReq> getAllRequests(@RequestHeader("Authorization") String authorizationHeader) {
		return requestService.getAllRequests();
	}


    /**
     * Updates the status of a request (Accepts/Rejects) by a checker (approver role).
     *
     * @param token The authorization token of the executor (checker).
     * @param processRequestDto The DTO containing the request ID, new status, and any remarks.
     * @return The updated CommonReq entity.
     * @throws JsonProcessingException If there is an issue processing the request data.
     */
	@PatchMapping("/update-request")
	public CommonReq updateRequestStatus(
			@RequestHeader("Authorization") String token,
			@RequestBody ProcessRequestDto processRequestDto
	) throws JsonProcessingException {
		String executorId = jwtUtil.getUserIdFromToken(token);
		// The service layer throws a ResourceNotFoundException if the optional is
		// empty,
		// which is caught by the GlobalExceptionHandler.
		return requestService.updateRequestStatus(processRequestDto, executorId).get();
	}


    /**
     * Cancels a pending request initiated by the user.
     *
     * @param token The authorization token of the user (must be the creator).
     * @param cancelRequestDto The DTO containing the request ID and optional remarks.
     * @return The updated CommonReq entity with status CANCELLED.
     */
    @PatchMapping("/cancel-request")
    public CommonReq cancelRequest(
            @RequestHeader("Authorization") String token,
            @Valid @RequestBody CancelRequestDto cancelRequestDto
    ) {
        String userId = jwtUtil.getUserIdFromToken(token);
        log.info("Received cancellation request for request ID: {} from user: {}", cancelRequestDto.getRequestId(), userId);
        return requestService.cancelRequest(cancelRequestDto, userId);
    }


    private final TemplateDiffService templateDiffService;

    @PostMapping("/template-diff")
    public TemplateDiffResponseDto compareTemplates(
            @RequestBody TemplateDiffRequest request
    ) {
        return templateDiffService.compareByRequestId(request.getRequestId());
    }

    @Data
    public static class TemplateDiffRequest {
        private Long requestId;
    }

}






// =====================================================================================
// service/TemplateDiffService.java
// ==========‚âà==========================================================================



package com.tcs.fincore.CommonRequestService.service;

import com.tcs.fincore.CommonRequestService.dto.ReportTemplateDto;
import com.tcs.fincore.CommonRequestService.dto.TemplateDiffResponseDto;

public interface TemplateDiffService {

    TemplateDiffResponseDto compare(
            ReportTemplateDto oldTemplate,
            ReportTemplateDto newTemplate
    );
}







// =====================================================================================
// service/TemplateDiffServiceImpl.java
// ==========‚âà==========================================================================



package com.tcs.fincore.CommonRequestService.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.tcs.fincore.CommonRequestService.dto.ReportTemplateDto;
import com.tcs.fincore.CommonRequestService.dto.TemplateDiffResponseDto;
import com.tcs.fincore.CommonRequestService.dto.ValueDiff;
import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.repository.CommonRequestRepository;
import com.tcs.fincore.CommonRequestService.repository.ReportTemplateRepository;
import com.tcs.fincore.CommonRequestService.util.JsonCompareUtil;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;

@Service
@RequiredArgsConstructor
public class TemplateDiffServiceImpl implements TemplateDiffService {

    private final CommonRequestRepository commonRequestRepository;
    private final ReportTemplateRepository reportTemplateRepository;
    private final JsonCompareUtil jsonCompareUtil;
    private final ObjectMapper objectMapper;

    @Override
    public TemplateDiffResponseDto compareByRequestId(Long requestId) {

        // 1Ô∏è‚É£ Fetch NEW template from request payload
        CommonReq req = commonRequestRepository.findById(requestId)
                .orElseThrow(() ->
                        new IllegalArgumentException("Request not found: " + requestId));

        ReportTemplateDto newTemplate =
                parseTemplate(req.getPayload(), "request payload");

        // 2Ô∏è‚É£ Extract reportId safely
        String reportId = newTemplate.getTemplate()
                .getReportMeta()
                .getReportId();

        // 3Ô∏è‚É£ Fetch OLD ACTIVE template JSON from DB
        String oldTemplateJson = reportTemplateRepository
                .findFirstByReportIdAndStatus(reportId, "ACTIVE")
                .map(rt -> rt.getTemplateJson()) // IMPORTANT: JSON string
                .orElseThrow(() ->
                        new IllegalStateException(
                                "Active template not found for reportId: " + reportId));

        ReportTemplateDto oldTemplate =
                parseTemplate(oldTemplateJson, "stored template");

        // 4Ô∏è‚É£ Run diff logic
        Map<String, Map<String, ValueDiff>> diffs =
                jsonCompareUtil.compareTemplates(oldTemplate, newTemplate);

        // 5Ô∏è‚É£ Response
        return TemplateDiffResponseDto.builder()
                .oldTemplate(oldTemplate)
                .newTemplate(newTemplate)
                .cellDiffs(diffs)
                .build();
    }

    /**
     * Handles BOTH payload shapes:
     * 1) Wrapped { "template": { ... } }
     * 2) Flat { "templateMeta", "reportMeta", "reportData" }
     */
    private ReportTemplateDto parseTemplate(String json, String source) {
        try {
            // Try normal DTO parse
            ReportTemplateDto dto =
                    objectMapper.readValue(json, ReportTemplateDto.class);

            if (dto.getTemplate() != null) {
                return dto;
            }

            // Fallback: wrap flat JSON into Template
            Map<String, Object> raw =
                    objectMapper.readValue(json, Map.class);

            ReportTemplateDto.Template template =
                    ReportTemplateDto.Template.builder()
                            .templateMeta(objectMapper.convertValue(
                                    raw.get("templateMeta"),
                                    ReportTemplateDto.TemplateMeta.class))
                            .reportMeta(objectMapper.convertValue(
                                    raw.get("reportMeta"),
                                    ReportTemplateDto.ReportMeta.class))
                            .reportData(objectMapper.convertValue(
                                    raw.get("reportData"),
                                    ReportTemplateDto.ReportData.class))
                            .build();

            return ReportTemplateDto.builder()
                    .template(template)
                    .variants(List.of())
                    .build();

        } catch (Exception e) {
            throw new IllegalStateException(
                    "Invalid " + source + " JSON", e);
        }
    }
}






// =====================================================================================
// util/JsonCompareUtil.java
// ==========‚âà==========================================================================




package com.tcs.fincore.CommonRequestService.util;

import com.tcs.fincore.CommonRequestService.dto.ReportTemplateDto;
import com.tcs.fincore.CommonRequestService.dto.ValueDiff;
import org.springframework.stereotype.Component;

import java.util.*;

@Component
public class JsonCompareUtil {

    public Map<String, Map<String, ValueDiff>> compareTemplates(
            ReportTemplateDto oldTemplate,
            ReportTemplateDto newTemplate
    ) {

        Map<String, Map<String, ValueDiff>> diffs = new LinkedHashMap<>();

        List<ReportTemplateDto.Row> oldRows =
                oldTemplate.getTemplate().getReportData().getRows();
        List<ReportTemplateDto.Row> newRows =
                newTemplate.getTemplate().getReportData().getRows();

        for (int r = 0; r < Math.max(oldRows.size(), newRows.size()); r++) {

            ReportTemplateDto.Row oldRow = r < oldRows.size() ? oldRows.get(r) : null;
            ReportTemplateDto.Row newRow = r < newRows.size() ? newRows.get(r) : null;

            if (oldRow == null || newRow == null) continue;

            List<ReportTemplateDto.Cell> oldCells = oldRow.getCells();
            List<ReportTemplateDto.Cell> newCells = newRow.getCells();

            for (int c = 0; c < Math.max(oldCells.size(), newCells.size()); c++) {

                ReportTemplateDto.Cell oldCell = c < oldCells.size() ? oldCells.get(c) : null;
                ReportTemplateDto.Cell newCell = c < newCells.size() ? newCells.get(c) : null;

                if (oldCell == null || newCell == null) continue;

                // ‚úÖ ALWAYS NON-NULL KEY
                String cellKey = buildCellKey(oldCell, newCell, r, c);

                Map<String, ValueDiff> fieldDiffs = compareCell(oldCell, newCell);

                if (!fieldDiffs.isEmpty()) {
                    diffs.put(cellKey, fieldDiffs);
                }
            }
        }

        return diffs;
    }

    // --------------------------------------------------------

    private Map<String, ValueDiff> compareCell(
            ReportTemplateDto.Cell oldCell,
            ReportTemplateDto.Cell newCell
    ) {
        Map<String, ValueDiff> diffs = new LinkedHashMap<>();

        compareField("type", oldCell.getType(), newCell.getType(), diffs);
        compareField("value", oldCell.getValue(), newCell.getValue(), diffs);
        compareField("expression", oldCell.getExpression(), newCell.getExpression(), diffs);
        compareField("variables", oldCell.getVariables(), newCell.getVariables(), diffs);
        compareField("source", oldCell.getSource(), newCell.getSource(), diffs);
        compareField("render", oldCell.getRender(), newCell.getRender(), diffs);

        return diffs;
    }

    private void compareField(
            String field,
            Object oldVal,
            Object newVal,
            Map<String, ValueDiff> diffs
    ) {
        if (!Objects.equals(oldVal, newVal)) {
            diffs.put(field, new ValueDiff(oldVal, newVal));
        }
    }

    // --------------------------------------------------------

    /**
     * üîê GUARANTEED NON-NULL KEY
     * Used by frontend to locate the exact cell
     */
    private String buildCellKey(
            ReportTemplateDto.Cell oldCell,
            ReportTemplateDto.Cell newCell,
            int rowIndex,
            int colIndex
    ) {
        if (newCell.getId() != null) {
            return newCell.getId();
        }
        if (oldCell.getId() != null) {
            return oldCell.getId();
        }

        // deterministic fallback (VERY IMPORTANT)
        return "R" + rowIndex + "C" + colIndex;
    }
}
