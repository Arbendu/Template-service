// =====================================================================================
// dto/ValueDiff.java
// ==========‚âà==========================================================================

package com.tcs.fincore.CommonRequestService.dto;

import lombok.*;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ValueDiff {
    private Object oldValue;
    private Object newValue;
}





// =====================================================================================
// dto/TemplateDiffResponseDto.java
// ==========‚âà==========================================================================


package com.tcs.fincore.CommonRequestService.dto;

import lombok.*;

import java.util.Map;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TemplateDiffResponseDto {

    private ReportTemplateDto oldTemplate;
    private ReportTemplateDto newTemplate;

    /**
     * cellId -> (fieldName -> old/new value)
     */
    private Map<String, Map<String, ValueDiff>> cellDiffs;
}





// =====================================================================================
// controller 
// ==========‚âà==========================================================================



package com.tcs.fincore.CommonRequestService.controller;

import com.tcs.fincore.CommonRequestService.dto.ReportTemplateDto;
import com.tcs.fincore.CommonRequestService.dto.TemplateDiffResponseDto;
import com.tcs.fincore.CommonRequestService.service.TemplateDiffService;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/CR/template-diff")
@RequiredArgsConstructor
public class TemplateDiffController {

    private final TemplateDiffService templateDiffService;

    @PostMapping
    public TemplateDiffResponseDto compareTemplates(
            @RequestBody DiffRequest request
    ) {
        return templateDiffService.compare(
                request.getOldTemplate(),
                request.getNewTemplate()
        );
    }

    @Data
    public static class DiffRequest {
        private ReportTemplateDto oldTemplate;
        private ReportTemplateDto newTemplate;
    }
}






// =====================================================================================
// service/TemplateDiffService.java
// ==========‚âà==========================================================================



package com.tcs.fincore.CommonRequestService.service;

import com.tcs.fincore.CommonRequestService.dto.ReportTemplateDto;
import com.tcs.fincore.CommonRequestService.dto.TemplateDiffResponseDto;

public interface TemplateDiffService {

    TemplateDiffResponseDto compare(
            ReportTemplateDto oldTemplate,
            ReportTemplateDto newTemplate
    );
}







// =====================================================================================
// service/TemplateDiffServiceImpl.java
// ==========‚âà==========================================================================



package com.tcs.fincore.CommonRequestService.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.tcs.fincore.CommonRequestService.dto.ReportTemplateDto;
import com.tcs.fincore.CommonRequestService.dto.TemplateDiffResponseDto;
import com.tcs.fincore.CommonRequestService.dto.ValueDiff;
import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.repository.CommonRequestRepository;
import com.tcs.fincore.CommonRequestService.repository.ReportTemplateRepository;
import com.tcs.fincore.CommonRequestService.util.JsonCompareUtil;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;

@Service
@RequiredArgsConstructor
public class TemplateDiffServiceImpl implements TemplateDiffService {

    private final CommonRequestRepository commonRequestRepository;
    private final ReportTemplateRepository reportTemplateRepository;
    private final JsonCompareUtil jsonCompareUtil;
    private final ObjectMapper objectMapper;

    @Override
    public TemplateDiffResponseDto compareByRequestId(Long requestId) {

        // 1Ô∏è‚É£ Fetch NEW template from request payload
        CommonReq req = commonRequestRepository.findById(requestId)
                .orElseThrow(() ->
                        new IllegalArgumentException("Request not found: " + requestId));

        ReportTemplateDto newTemplate =
                parseTemplate(req.getPayload(), "request payload");

        // 2Ô∏è‚É£ Extract reportId safely
        String reportId = newTemplate.getTemplate()
                .getReportMeta()
                .getReportId();

        // 3Ô∏è‚É£ Fetch OLD ACTIVE template JSON from DB
        String oldTemplateJson = reportTemplateRepository
                .findFirstByReportIdAndStatus(reportId, "ACTIVE")
                .map(rt -> rt.getTemplateJson()) // IMPORTANT: JSON string
                .orElseThrow(() ->
                        new IllegalStateException(
                                "Active template not found for reportId: " + reportId));

        ReportTemplateDto oldTemplate =
                parseTemplate(oldTemplateJson, "stored template");

        // 4Ô∏è‚É£ Run diff logic
        Map<String, Map<String, ValueDiff>> diffs =
                jsonCompareUtil.compareTemplates(oldTemplate, newTemplate);

        // 5Ô∏è‚É£ Response
        return TemplateDiffResponseDto.builder()
                .oldTemplate(oldTemplate)
                .newTemplate(newTemplate)
                .cellDiffs(diffs)
                .build();
    }

    /**
     * Handles BOTH payload shapes:
     * 1) Wrapped { "template": { ... } }
     * 2) Flat { "templateMeta", "reportMeta", "reportData" }
     */
    private ReportTemplateDto parseTemplate(String json, String source) {
        try {
            // Try normal DTO parse
            ReportTemplateDto dto =
                    objectMapper.readValue(json, ReportTemplateDto.class);

            if (dto.getTemplate() != null) {
                return dto;
            }

            // Fallback: wrap flat JSON into Template
            Map<String, Object> raw =
                    objectMapper.readValue(json, Map.class);

            ReportTemplateDto.Template template =
                    ReportTemplateDto.Template.builder()
                            .templateMeta(objectMapper.convertValue(
                                    raw.get("templateMeta"),
                                    ReportTemplateDto.TemplateMeta.class))
                            .reportMeta(objectMapper.convertValue(
                                    raw.get("reportMeta"),
                                    ReportTemplateDto.ReportMeta.class))
                            .reportData(objectMapper.convertValue(
                                    raw.get("reportData"),
                                    ReportTemplateDto.ReportData.class))
                            .build();

            return ReportTemplateDto.builder()
                    .template(template)
                    .variants(List.of())
                    .build();

        } catch (Exception e) {
            throw new IllegalStateException(
                    "Invalid " + source + " JSON", e);
        }
    }
}






// =====================================================================================
// util/JsonCompareUtil.java
// ==========‚âà==========================================================================




package com.tcs.fincore.CommonRequestService.util;

import com.tcs.fincore.CommonRequestService.dto.ReportTemplateDto;
import com.tcs.fincore.CommonRequestService.dto.ValueDiff;
import org.springframework.stereotype.Component;

import java.util.*;

@Component
public class JsonCompareUtil {

    public Map<String, Map<String, ValueDiff>> compareTemplates(
            ReportTemplateDto oldTemplate,
            ReportTemplateDto newTemplate
    ) {

        Map<String, Map<String, ValueDiff>> diffs = new LinkedHashMap<>();

        List<ReportTemplateDto.Row> oldRows =
                oldTemplate.getTemplate().getReportData().getRows();
        List<ReportTemplateDto.Row> newRows =
                newTemplate.getTemplate().getReportData().getRows();

        for (int r = 0; r < Math.max(oldRows.size(), newRows.size()); r++) {

            ReportTemplateDto.Row oldRow = r < oldRows.size() ? oldRows.get(r) : null;
            ReportTemplateDto.Row newRow = r < newRows.size() ? newRows.get(r) : null;

            if (oldRow == null || newRow == null) continue;

            List<ReportTemplateDto.Cell> oldCells = oldRow.getCells();
            List<ReportTemplateDto.Cell> newCells = newRow.getCells();

            for (int c = 0; c < Math.max(oldCells.size(), newCells.size()); c++) {

                ReportTemplateDto.Cell oldCell = c < oldCells.size() ? oldCells.get(c) : null;
                ReportTemplateDto.Cell newCell = c < newCells.size() ? newCells.get(c) : null;

                if (oldCell == null || newCell == null) continue;

                // ‚úÖ ALWAYS NON-NULL KEY
                String cellKey = buildCellKey(oldCell, newCell, r, c);

                Map<String, ValueDiff> fieldDiffs = compareCell(oldCell, newCell);

                if (!fieldDiffs.isEmpty()) {
                    diffs.put(cellKey, fieldDiffs);
                }
            }
        }

        return diffs;
    }

    // --------------------------------------------------------

    private Map<String, ValueDiff> compareCell(
            ReportTemplateDto.Cell oldCell,
            ReportTemplateDto.Cell newCell
    ) {
        Map<String, ValueDiff> diffs = new LinkedHashMap<>();

        compareField("type", oldCell.getType(), newCell.getType(), diffs);
        compareField("value", oldCell.getValue(), newCell.getValue(), diffs);
        compareField("expression", oldCell.getExpression(), newCell.getExpression(), diffs);
        compareField("variables", oldCell.getVariables(), newCell.getVariables(), diffs);
        compareField("source", oldCell.getSource(), newCell.getSource(), diffs);
        compareField("render", oldCell.getRender(), newCell.getRender(), diffs);

        return diffs;
    }

    private void compareField(
            String field,
            Object oldVal,
            Object newVal,
            Map<String, ValueDiff> diffs
    ) {
        if (!Objects.equals(oldVal, newVal)) {
            diffs.put(field, new ValueDiff(oldVal, newVal));
        }
    }

    // --------------------------------------------------------

    /**
     * üîê GUARANTEED NON-NULL KEY
     * Used by frontend to locate the exact cell
     */
    private String buildCellKey(
            ReportTemplateDto.Cell oldCell,
            ReportTemplateDto.Cell newCell,
            int rowIndex,
            int colIndex
    ) {
        if (newCell.getId() != null) {
            return newCell.getId();
        }
        if (oldCell.getId() != null) {
            return oldCell.getId();
        }

        // deterministic fallback (VERY IMPORTANT)
        return "R" + rowIndex + "C" + colIndex;
    }
}
