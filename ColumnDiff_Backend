// ===============================================================================================================================================================================
// JsonCompareUtill.java
// ================================================================================================================================================================================




package com.fincore.TemplateConfigurationService.util;

import com.fincore.TemplateConfigurationService.dto.TemplatePayload;
import com.fincore.TemplateConfigurationService.dto.ValueDiff;
import org.springframework.stereotype.Component;

import java.util.*;

@Component
public class JsonCompareUtil {

    /**
     * Compare Rows and Cells
     */
    public Map<String, Map<String, ValueDiff>> compareCells(
            TemplatePayload oldTemplate,
            TemplatePayload newTemplate
    ) {
        Map<String, Map<String, ValueDiff>> diffs = new LinkedHashMap<>();

        List<TemplatePayload.Row> oldRows = getRowsSafe(oldTemplate);
        List<TemplatePayload.Row> newRows = getRowsSafe(newTemplate);

        int maxRows = Math.max(oldRows.size(), newRows.size());

        for (int r = 0; r < maxRows; r++) {
            TemplatePayload.Row oldRow = r < oldRows.size() ? oldRows.get(r) : null;
            TemplatePayload.Row newRow = r < newRows.size() ? newRows.get(r) : null;

            // If a row is completely missing or added, you might handle it here.
            // For now, we proceed to check cells if both rows exist (or partially exist)
            List<TemplatePayload.Cell> oldCells = (oldRow != null) ? oldRow.getCells() : Collections.emptyList();
            List<TemplatePayload.Cell> newCells = (newRow != null) ? newRow.getCells() : Collections.emptyList();

            int maxCells = Math.max(oldCells.size(), newCells.size());

            for (int c = 0; c < maxCells; c++) {
                TemplatePayload.Cell oldCell = c < oldCells.size() ? oldCells.get(c) : null;
                TemplatePayload.Cell newCell = c < newCells.size() ? newCells.get(c) : null;

                if (oldCell == null && newCell == null) continue;

                String cellKey = buildCellKey(oldCell, newCell, r, c);
                Map<String, ValueDiff> fieldDiffs = compareCellFields(oldCell, newCell);

                if (!fieldDiffs.isEmpty()) {
                    diffs.put(cellKey, fieldDiffs);
                }
            }
        }
        return diffs;
    }

    /**
     * Compare Column Definitions
     */
    public Map<String, Map<String, ValueDiff>> compareColumns(
            TemplatePayload oldTemplate,
            TemplatePayload newTemplate
    ) {
        Map<String, Map<String, ValueDiff>> diffs = new LinkedHashMap<>();

        List<TemplatePayload.ColumnDefinition> oldCols = getColumnsSafe(oldTemplate);
        List<TemplatePayload.ColumnDefinition> newCols = getColumnsSafe(newTemplate);

        int maxCols = Math.max(oldCols.size(), newCols.size());

        for (int i = 0; i < maxCols; i++) {
            TemplatePayload.ColumnDefinition oldCol = i < oldCols.size() ? oldCols.get(i) : null;
            TemplatePayload.ColumnDefinition newCol = i < newCols.size() ? newCols.get(i) : null;

            if (oldCol == null && newCol == null) continue;

            // Generate a reliable key for the frontend to identify which column changed
            String colKey = buildColumnKey(oldCol, newCol, i);
            
            Map<String, ValueDiff> fieldDiffs = compareColumnFields(oldCol, newCol);

            if (!fieldDiffs.isEmpty()) {
                diffs.put(colKey, fieldDiffs);
            }
        }
        return diffs;
    }

    // --------------------------------------------------------
    // Comparison Logic Helpers
    // --------------------------------------------------------

    private Map<String, ValueDiff> compareCellFields(TemplatePayload.Cell oldCell, TemplatePayload.Cell newCell) {
        Map<String, ValueDiff> diffs = new LinkedHashMap<>();
        
        // Handle nulls (Added/Removed cells)
        if (oldCell == null && newCell != null) {
             // Entire cell is new. We can mark key fields as changed from null -> value
             compareField("value", null, newCell.getValue(), diffs);
             return diffs;
        }
        if (oldCell != null && newCell == null) {
             // Cell removed
             compareField("value", oldCell.getValue(), null, diffs);
             return diffs;
        }

        compareField("type", oldCell.getType(), newCell.getType(), diffs);
        compareField("value", oldCell.getValue(), newCell.getValue(), diffs);
        compareField("expression", oldCell.getExpression(), newCell.getExpression(), diffs);
        compareField("variables", oldCell.getVariables(), newCell.getVariables(), diffs);
        compareField("source", oldCell.getSource(), newCell.getSource(), diffs);
        compareField("render", oldCell.getRender(), newCell.getRender(), diffs);
        return diffs;
    }

    private Map<String, ValueDiff> compareColumnFields(TemplatePayload.ColumnDefinition oldCol, TemplatePayload.ColumnDefinition newCol) {
        Map<String, ValueDiff> diffs = new LinkedHashMap<>();

        if (oldCol == null && newCol != null) {
            compareField("name", null, newCol.getName(), diffs);
            return diffs;
        }
        if (oldCol != null && newCol == null) {
            compareField("name", oldCol.getName(), null, diffs);
            return diffs;
        }

        compareField("id", oldCol.getId(), newCol.getId(), diffs);
        compareField("name", oldCol.getName(), newCol.getName(), diffs);
        compareField("format", oldCol.getFormat(), newCol.getFormat(), diffs);
        
        return diffs;
    }

    private void compareField(String field, Object oldVal, Object newVal, Map<String, ValueDiff> diffs) {
        if (!Objects.equals(oldVal, newVal)) {
            diffs.put(field, new ValueDiff(oldVal, newVal));
        }
    }

    // --------------------------------------------------------
    // Key Generation Helpers
    // --------------------------------------------------------

    private String buildCellKey(TemplatePayload.Cell oldCell, TemplatePayload.Cell newCell, int r, int c) {
        if (newCell != null && newCell.getId() != null) return newCell.getId();
        if (oldCell != null && oldCell.getId() != null) return oldCell.getId();
        // Deterministic fallback
        return "R" + r + "C" + c;
    }

    private String buildColumnKey(TemplatePayload.ColumnDefinition oldCol, TemplatePayload.ColumnDefinition newCol, int index) {
        if (newCol != null && newCol.getId() != null) return newCol.getId();
        if (oldCol != null && oldCol.getId() != null) return oldCol.getId();
        // Deterministic fallback
        return "C" + index;
    }

    // --------------------------------------------------------
    // Null-Safe Accessors
    // --------------------------------------------------------

    private List<TemplatePayload.Row> getRowsSafe(TemplatePayload t) {
        if (t == null || t.getTemplate() == null 
            || t.getTemplate().getReportData() == null 
            || t.getTemplate().getReportData().getRows() == null) {
            return Collections.emptyList();
        }
        return t.getTemplate().getReportData().getRows();
    }

    private List<TemplatePayload.ColumnDefinition> getColumnsSafe(TemplatePayload t) {
        if (t == null || t.getTemplate() == null 
            || t.getTemplate().getReportData() == null 
            || t.getTemplate().getReportData().getColumns() == null) {
            return Collections.emptyList();
        }
        return t.getTemplate().getReportData().getColumns();
    }
}







// ==================================================================================================================================================================================
// TemplateDiffServiceImpl.java
// ==================================================================================================================================================================================


package com.fincore.TemplateConfigurationService.service.impl;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fincore.TemplateConfigurationService.dto.*;
import com.fincore.TemplateConfigurationService.entity.CommonReq;
import com.fincore.TemplateConfigurationService.repository.CommonRequestRepository;
import com.fincore.TemplateConfigurationService.repository.ReportTemplateRepository;
import com.fincore.TemplateConfigurationService.service.TemplateDiffService;
import com.fincore.TemplateConfigurationService.util.JsonCompareUtil;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;

@Service
@RequiredArgsConstructor
public class TemplateDiffServiceImpl implements TemplateDiffService {

    private final CommonRequestRepository commonRequestRepository;
    private final ReportTemplateRepository reportTemplateRepository;
    private final JsonCompareUtil jsonCompareUtil;
    private final ObjectMapper objectMapper;

    @Override
    public TemplateDiffResponseDto compareByRequestId(Long requestId) {

        // 1️⃣ Fetch NEW template from request payload
        CommonReq req = commonRequestRepository.findById(requestId)
                .orElseThrow(() ->
                        new IllegalArgumentException("Request not found: " + requestId));
        
        TemplatePayload newTemplate = parseTemplate(req.getPayload(), "request payload");

        // 2️⃣ Extract reportId safely
        String reportId = newTemplate.getTemplate()
                .getReportMeta()
                .getReportId();

        // 3️⃣ Fetch OLD ACTIVE template JSON from DB
        String oldTemplateJson = reportTemplateRepository
                .findFirstByReportIdAndStatus(reportId, "ACTIVE")
                .map(rt -> rt.getTemplateJson()) 
                .orElseThrow(() ->
                        new IllegalStateException("Active template not found for reportId: " + reportId));

        TemplatePayload oldTemplate = parseTemplate(oldTemplateJson, "stored template");

        // 4️⃣ Run diff logic
        // 4a. Compare Cells
        Map<String, Map<String, ValueDiff>> cellDiffs =
                jsonCompareUtil.compareCells(oldTemplate, newTemplate);

        // 4b. Compare Columns (NEW LOGIC)
        Map<String, Map<String, ValueDiff>> columnDiffs =
                jsonCompareUtil.compareColumns(oldTemplate, newTemplate);

        // 5️⃣ Response
        return TemplateDiffResponseDto.builder()
                .oldTemplate(oldTemplate)
                .newTemplate(newTemplate)
                .cellDiffs(cellDiffs)
                .columnDiffs(columnDiffs) // Add columns to response
                .build();
    }

    private TemplatePayload parseTemplate(String json, String source) {
        try {
            TemplatePayload dto = objectMapper.readValue(json, TemplatePayload.class);
            if (dto.getTemplate() != null) {
                return dto;
            }

            // Fallback: wrap flat JSON into Template structure
            Map<String, Object> raw = objectMapper.readValue(json, Map.class);
            TemplatePayload.Template template = TemplatePayload.Template.builder()
                    .templateMeta(objectMapper.convertValue(raw.get("templateMeta"), TemplatePayload.TemplateMeta.class))
                    .reportMeta(objectMapper.convertValue(raw.get("reportMeta"), TemplatePayload.ReportMeta.class))
                    .reportData(objectMapper.convertValue(raw.get("reportData"), TemplatePayload.ReportData.class))
                    .build();

            return TemplatePayload.builder()
                    .template(template)
                    .variants(List.of())
                    .build();
        } catch (Exception e) {
            throw new IllegalStateException("Invalid " + source + " JSON", e);
        }
    }
}
