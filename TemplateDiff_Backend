// ===============================================================================================================================================================================================================================================
// entity/ReportTemplate
// ===============================================================================================================================================================================================================================================

package com.fincore.TemplateConfigurationService.entity;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "RB_REPORT_TEMPLATE")
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ReportTemplate {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "TEMPLATE_ID")
    private String templateId;

    @Column(name = "VERSION_NO")
    private Integer versionNo;

    @Column(name = "REPORT_ID")
    private String reportId;

    @Column(name = "TEMPLATE_NAME", length = 200)
    private String templateName;

    @Column(name = "DESCRIPTION", length = 500)
    private String description;

    @Column(name = "STATUS", length = 30)
    private String status;

    @Lob
    @Column(name = "TEMPLATE_JSON")
    private String templateJson;

    @Column(name = "CREATED_BY", length = 50)
    private String createdBy;

    @Column(name = "CREATED_AT")
    private LocalDateTime createdAt;

    @Column(name = "UPDATED_BY", length = 50)
    private String updatedBy;

    @Column(name = "UPDATED_AT")
    private LocalDateTime updatedAt;

    @Column(name = "REMARKS", length = 500)
    private String remarks;
}











// ===============================================================================================================================================================================================================================================
// entity/ReportTemplateHistory
// ===============================================================================================================================================================================================================================================

package com.fincore.TemplateConfigurationService.entity;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "RB_REPORT_TEMPLATE_HISTORY")
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ReportTemplateHistory {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "HISTORY_ID")
    private long historyId;

    // I store the original Template ID for reference
    @Column(name = "TEMPLATE_ID")
    private String templateId;

    @Column(name = "VERSION_NO")
    private Integer versionNo;

    @Column(name = "report_id")
    private String reportId;

    @Column(name = "TEMPLATE_NAME", length = 200)
    private String templateName;

    @Column(name = "DESCRIPTION", length = 500)
    private String description;

    @Column(name = "STATUS",length = 30)
    private String status;

    // Snapshot of the main template json
    @Lob
    @Column(name = "TEMPLATE_JSON")
    private String templateJson;

    // Snapshot of all variants + params + rules as a JSON array
    @Lob
    @Column(name = "VARIANTS_JSON")
    private String variantsJson;

    @Column(name = "CREATED_BY", length = 50)
    private String createdBy;

    @Column(name = "CREATED_AT")
    private LocalDateTime createdAt;

    @Column(name = "ARCHIVED_BY", length = 50)
    private String archivedBy;

    @Column(name = "ARCHIVED_AT")
    private LocalDateTime archivedAt;

    @Column(name = "REMARKS", length = 500)
    private String remarks;

}







// ===============================================================================================================================================================================================================================================
// entity/CommonReq.java
// ===============================================================================================================================================================================================================================================

package com.fincore.TemplateConfigurationService.entity;

import com.fasterxml.jackson.annotation.JsonRawValue;
import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDateTime;

/**
 * Represents a common request entity stored in the "COMMON_REQ" database table.
 * This entity is used to log and track various types of requests within the system,
 * including their status, payload, and execution details.
 *
 * All enum fields are now handled by their respective {@link Converter @Converter(autoApply = true)} classes.
 */
@Getter
@Setter
@Entity
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Table(name = "COMMON_REQ")
public class CommonReq {
    /**
     * The unique identifier for the request.
     * Generated using a sequence "COMMON_REQ_SEQ".
     */
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "COMMON_REQ_id_gen")
    @SequenceGenerator(name = "COMMON_REQ_id_gen", sequenceName = "COMMON_REQ_SEQ", allocationSize = 1)
    @Column(name = "REQ_ID", nullable = false)
    private Long id;

    /**
     * The type of request (e.g., New, Update, Delete).
     * Mapped to the "REQ_TYPE" column. Handled by an auto-applied JPA converter.
     */
    @Column(name = "REQ_TYPE", nullable = false, length = 20)
    private String reqType;

    /**
     * The specific type of change associated with the request.
     * Mapped to the "CHANGE_TYPE" column. Handled by an auto-applied JPA converter.
     */
    @Column(name = "CHANGE_TYPE", nullable = false, length = 2)
    private String changeType;

    /**
     * The current status of the request (e.g., PENDING, APPROVED, REJECTED).
     * Mapped to the "REQ_STATUS" column. Handled by an auto-applied JPA converter.
     */
    @Column(name = "REQ_STATUS", nullable = false, length = 2)
    private String reqStatus;

    /**
     * The Oracle's SYSDATE/CURRENT_TIMESTAMP when the request was created.
     * Automatically set upon entity creation and is not updatable.
     * the value comes from not the Java JVM time, fixes time mismatch issues
     */
    @Column(name = "REQ_DATE", nullable = false, updatable = false)
    private LocalDateTime reqDate;

    /**
     * The ID of the user who created the request.
     * Mapped to the "CREATOR_ID" column.
     */
    @Column(name = "CREATOR_ID", nullable = false, length = 12)
    private String creatorId;

    /**
     * The timestamp when the request was executed or processed.
     * Mapped to the "EXECUTION_DATE" column.
     */
    @Column(name = "EXECUTION_DATE")
    private LocalDateTime executionDate;

    /**
     * General remarks regarding the execution process.
     * Stored as a Large Object (LOB) in the "EXECUTION_REMARKS" column.
     */
    @Lob
    @Column(name = "EXECUTION_REMARKS")
    private String executionRemarks;

    /**
     * The ID of the user who executed or processed the request.
     * Mapped to the "EXECUTOR_ID" column.
     */
    @Column(name = "EXECUTOR_ID", length = 12)
    private String executorId;

    /**
     * Specific remarks provided by the executor.
     * Mapped to the "EXECUTOR_REMARKS" column.
     */
    @Column(name = "EXECUTOR_REMARKS", length = 500)
    private String executorRemarks;

    /**
     * The request's main data payload, typically a JSON string.
     * Stored as a Large Object (LOB) in the "PAYLOAD" column.
     */
    @Lob
    @Column(name = "PAYLOAD", nullable = false)
    private String payload;

    /**
     * An identifier for the target entity affected by the request (e.g., account number, user ID).
     * Mapped to the "TARGET_ID" column.
     */
    @Column(name = "TARGET_ID", length = 4000)
    private String targetId;


    /**
     * Retrieves the payload and marks it for raw JSON serialization.
     *
     * When this entity is serialized to JSON (e.g., in a REST API response),
     * the value returned by this getter will be inserted directly as raw JSON,
     * assuming the {@link #payload} field already contains a valid JSON string.
     *
     * @return The raw JSON payload string.
     */
    @JsonRawValue
    public String getPayload() {
        return payload;
    }
}








// ===============================================================================================================================================================================================================================================
// dto/ValueDiff.java
// ===============================================================================================================================================================================================================================================
package com.fincore.TemplateConfigurationService.dto;

import lombok.*;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ValueDiff {
    private Object oldValue;
    private Object newValue;
}



// ===============================================================================================================================================================================================================================================
// dto/TemplatePayload.java
// ===============================================================================================================================================================================================================================================



package com.fincore.TemplateConfigurationService.dto;

import jakarta.validation.constraints.NotNull;
import lombok.*;

import javax.swing.*;
import java.util.List;
import java.util.Map;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TemplatePayload{

    @NotNull
    private Template template;

    @NotNull
    private List<VariantDto> variants;

    private String remarks;


    @Getter
    @Setter
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class Template {
        @NotNull
        private TemplateMeta templateMeta;

        @NotNull
        private ReportMeta reportMeta;

//        private List<Map<String, Object>> globalParams;
        private List<GlobalParamDef> globalParams;

        @NotNull
        private ReportData reportData;
    }

    @Getter
    @Setter
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class TemplateMeta {
        private String templateId;
        private String version;
        private String description;
        // e.g. "A4", "LETTER"; "portrait" / "landscape"
        private String pageSize;
        private String pageOrientation;
        private String headerLayout;  //layout (1-col, 2-col, etc.)
    }

    @Data
    public static class ReportMeta {
        private String reportName;
        private String reportId;
        private List<Map<String, String>> extras;
    }

    @Data
    public static class ReportData {
        private List<ColumnDefinition> columns;
        private List<Row> rows;
    }
    @Data
    public static class GlobalParamDef {
        private String name;           // e.g., "BRANCH_NAME"
        private String dataType;       // STRING, NUMBER, DATE, BOOLEAN
        private String label;

        // NEW: Mode of execution
        private ParamMode mode;        // INPUT, EXPRESSION, QUERY

        // For INPUT
        private Object defaultValue;
        private boolean required;

        // For EXPRESSION
        private String expression;     // e.g., "#{DateUtils.addDays(G.REPORT_DATE, -1)}"

        // For QUERY
        private ParamDataSource source; // DB Config
    }

    public enum ParamMode {
        INPUT,          // Provided by user or defaults
        EXPRESSION,     // Calculated using JEXL
        QUERY           // Fetched from Database
    }

    @Data
    public static class ParamDataSource {
        private String type;           // DB_VALUE, DB_SUM, etc.
        private String table;
        private String column;
        // Filters: Map<ColumnName, List<Condition>>
        private Map<String, Object> filters;
    }

    @Data
    public static class ColumnDefinition {
        private String id;
        private String name;
        private Map<String, Object> format; // flexible formatting map
        private List<TemplateColumnFilter> templateColumnFilters;
    }

    @Data
    public static class TemplateColumnFilter {
        private String tableName;

        // Maps Column Name -> List of Conditions (e.g., "BALANCE": [{op:">", value:"0"}])
        private Map<String, Object> filters;
    }

    @Data
    public static class Row {
        /**
         * DATA|GROUP_START|GROUP_END|NOTE|BREAK|DYNAMIC (future)
         */
        private String id;
        private String rowType;
        private String rowTitle;
        private List<Cell> cells;

        // Extension point for dynamic blocks etc.
        // Example: { "type":"DB_LIST", "table":"...", "filters":{...}, "limit":100 }
        private Map<String, Object> dynamicConfig;
    }

    @Data
    public static class Cell {
        private String id;                     // assigned by TemplateProcessor (R{row}C{col})
        private String type;                   // TEXT, DB_*, FORMULA, etc.
        private Object value;                  // used for TEXT cells
        private String expression;             // used for formulas
        private Map<String, Object> variables; // formula vars (CELL_REF, DB_*, CONST, etc.)
        private Map<String, Object> source;    // for DB_* types: { table, column, filters }
        private Map<String, Object> render;    // { bold, colspan, rowspan, align, format, bgColor, ... }
    }


}









// ===============================================================================================================================================================================================================================================
// dto/TemplateDiffResponseDto.java
// ===============================================================================================================================================================================================================================================

package com.fincore.TemplateConfigurationService.dto;

import lombok.*;

import java.util.Map;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TemplateDiffResponseDto {

    private TemplatePayload oldTemplate;
    private TemplatePayload newTemplate;

    /**
     * cellId -> (fieldName -> old/new value)
     */
    private Map<String, Map<String, ValueDiff>> cellDiffs;

    /**
     * cellId -> (fieldName -> old/new value)
     */
    private Map<String, Map<String, ValueDiff>> columnDiffs;

     private Map<String, Map<String, ValueDiff>> globalParamDiffs;
}




// ===============================================================================================================================================================================================================================================
// controller 
// ===============================================================================================================================================================================================================================================

    package com.fincore.TemplateConfigurationService.controller;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fincore.TemplateConfigurationService.dto.*;
import com.fincore.TemplateConfigurationService.entity.ReportTemplate;
import com.fincore.TemplateConfigurationService.service.AllowedTableService;
import com.fincore.TemplateConfigurationService.service.TemplateDiffService;
import com.fincore.TemplateConfigurationService.service.TemplateService;
import com.fincore.TemplateConfigurationService.constants.ResponseMessages;
import com.fincore.TemplateConfigurationService.response.ApiResponse;
import com.fincore.commonutilities.jwt.JwtUtil;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;

@Slf4j
@RestController
@RequestMapping("/api")
@RequiredArgsConstructor
public class TemplateController {

    private final TemplateService templateService;
    private final TemplateDiffService templateDiffService;
    private final JwtUtil jwtUtil;

    @Autowired
    private AllowedTableService tableService;

    @GetMapping("/allowed-tables")
    public  ResponseEntity<List<AllowedTablesDTO>> getAllTables(){
        return ResponseEntity.ok(tableService.getTableWithColumnsAll());
    }

    @GetMapping("/{tableId}")
    public ResponseEntity<AllowedTablesDTO> getAllowedTables(@PathVariable Long tableId) {
        return ResponseEntity.ok(tableService.getTableWithColumns(tableId));
    }

    // -------------------------------------------------
    // CREATE / UPDATE TEMPLATE
    // -------------------------------------------------
    @PostMapping("/save")
    public ResponseEntity<ApiResponse> saveTemplate(
            @Valid @RequestBody TemplatePayload payload,
            @RequestHeader("Authorization") String token,
            HttpServletRequest request) {

        String userId = jwtUtil.getUserIdFromToken(token);

        log.info("API: Save Template called by {}", userId);

        ReportTemplate saved = templateService.createOrUpdateTemplate(payload, userId);

        ApiResponse response = ApiResponse.builder()
                .message(ResponseMessages.TEMPLATE_SAVED)
                .status("SUCCESS")
                .data(saved.getTemplateId())
                .timestamp(LocalDateTime.now())
                .path(request.getRequestURI())
                .build();

        return ResponseEntity.ok(response);
    }

    // -------------------------------------------------
    // GET TEMPLATE WITH VARIANTS
    // -------------------------------------------------
    @GetMapping("/getTemplate/{templateId}")
    public ResponseEntity<ApiResponse> getTemplate(
            @PathVariable String templateId,
            HttpServletRequest request) {

        log.info("API: Get Template {}", templateId);

        TemplateResponse payload = null;
        try {
            payload = templateService.getTemplateWithVariants(templateId);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }

        ApiResponse response = ApiResponse.builder()
                .message(ResponseMessages.TEMPLATE_FETCHED)
                .status("SUCCESS")
                .data(payload)
                .timestamp(LocalDateTime.now())
                .path(request.getRequestURI())
                .build();

        return ResponseEntity.ok(response);
    }

    // -------------------------------------------------
    // GET ALL TEMPLATES
    // -------------------------------------------------
    @GetMapping("/get-templates")
    public ResponseEntity<ApiResponse> getALLTemplates(HttpServletRequest request) {

        List<TemplateResponse> templates = templateService.getAllTemplates();

        ApiResponse response = ApiResponse.builder()
                .message(ResponseMessages.ALL_TEMPLATES_FETCHED)
                .status("SUCCESS")
                .data(templates)
                .timestamp(LocalDateTime.now())
                .path(request.getRequestURI())
                .build();

        return ResponseEntity.ok(response);
    }

    // -------------------------------------------------
    // DELETE TEMPLATE
    // -------------------------------------------------
    @DeleteMapping("/{templateId}")
    public ResponseEntity<ApiResponse> deleteTemplate(
            @PathVariable String templateId,
            HttpServletRequest request) {

        templateService.deleteTemplate(templateId);

        ApiResponse response = ApiResponse.builder()
                .message(ResponseMessages.TEMPLATE_DELETED)
                .status("SUCCESS")
                .timestamp(LocalDateTime.now())
                .path(request.getRequestURI())
                .build();

        return ResponseEntity.ok(response);
    }

    // ---------------------------------------------------
    // UPDATE STATUS
    // ---------------------------------------------------
    @PatchMapping("/status/{templateId}")
    public ResponseEntity<ApiResponse> updateTemplateStatus(
            @PathVariable String templateId,
            @RequestBody @Valid TemplateStatusRequest request,
            @RequestHeader("Authorization") String token
    ){
        String userId = jwtUtil.getUserIdFromToken(token);
        templateService.updateStatus(templateId, request.getStatus(), userId);
        ApiResponse response  = ApiResponse.builder()
                .message("Status updated successfully.")
                .status("SUCCESS")
                .timestamp(LocalDateTime.now())
                .build();
        return ResponseEntity.ok(response);
    }


    @PostMapping("/template-diff")
    public TemplateDiffResponseDto compareTemplates(
            @RequestBody TemplateDiffRequest request
    ) {
        log.info("Display the CompareTemplate dialog box {}", request.getRequestId());
        return templateDiffService.compareByRequestId(request.getRequestId());
    }

    @Data
    public static class TemplateDiffRequest {
        private Long requestId;
    }

}








// ===============================================================================================================================================================================================================================================
// repository/ReportTemplateHistoryRepository
// ===============================================================================================================================================================================================================================================

package com.fincore.TemplateConfigurationService.repository;

import com.fincore.TemplateConfigurationService.entity.ReportTemplateHistory;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface ReportTemplateHistoryRepository extends JpaRepository<ReportTemplateHistory, Long> {
    Optional<Object> findByTemplateIdAndVersionNo(String templateId, int version);
}







// ===============================================================================================================================================================================================================================================
// repository/ReportTemplateRepository
// ===============================================================================================================================================================================================================================================

package com.fincore.TemplateConfigurationService.repository;

import com.fincore.TemplateConfigurationService.entity.ReportTemplate;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface ReportTemplateRepository extends JpaRepository<ReportTemplate, String> {
    Optional<ReportTemplate> findFirstByReportId(String reportId);

    Optional<ReportTemplate> findFirstByReportIdAndStatus(String reportId, String status);

}








// ===============================================================================================================================================================================================================================================
// service/TemplateDiffService.java
// ===============================================================================================================================================================================================================================================



package com.fincore.TemplateConfigurationService.service;

import com.fincore.TemplateConfigurationService.dto.TemplateDiffResponseDto;

public interface TemplateDiffService {

    TemplateDiffResponseDto compareByRequestId(Long requestId);
}







// ===============================================================================================================================================================================================================================================
// service/TemplateDiffServiceImpl.java
// ===============================================================================================================================================================================================================================================



package com.fincore.TemplateConfigurationService.service.impl;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fincore.TemplateConfigurationService.dto.*;
import com.fincore.TemplateConfigurationService.entity.CommonReq;
import com.fincore.TemplateConfigurationService.entity.ReportTemplate;
import com.fincore.TemplateConfigurationService.entity.ReportVariant;
import com.fincore.TemplateConfigurationService.repository.CommonRequestRepository;
import com.fincore.TemplateConfigurationService.repository.ReportTemplateRepository;
import com.fincore.TemplateConfigurationService.repository.ReportVariantRepository;
import com.fincore.TemplateConfigurationService.service.TemplateDiffService;
import com.fincore.TemplateConfigurationService.util.JsonCompareUtil;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@Service
@RequiredArgsConstructor
public class TemplateDiffServiceImpl implements TemplateDiffService {

    private final CommonRequestRepository commonRequestRepository;
    private final ReportTemplateRepository reportTemplateRepository;
    private final ReportVariantRepository reportVariantRepository;
    private final JsonCompareUtil jsonCompareUtil;
    private final ObjectMapper objectMapper;

    @Override
    public TemplateDiffResponseDto compareByRequestId(Long requestId) {

        // 1️⃣ Fetch NEW template from request payload
        CommonReq req = commonRequestRepository.findById(requestId)
                .orElseThrow(() ->
                        new IllegalArgumentException("Request not found: " + requestId));

        TemplatePayload newTemplate = parseTemplate(req.getPayload(), "request payload");

        // 2️⃣ Extract reportId safely
        String reportId = newTemplate.getTemplate()
                .getReportMeta()
                .getReportId();

        // 3️⃣ Fetch OLD ACTIVE template from DB
        ReportTemplate oldEntity = reportTemplateRepository
                .findFirstByReportIdAndStatus(reportId, "ACTIVE")
                .orElseThrow(() -> new IllegalStateException("Active template not found"));

        // Parse old template AND its variants
        TemplatePayload oldTemplate = parseTemplate(oldEntity.getTemplateJson(), "stored template");

//        String oldTemplateJson = reportTemplateRepository
//                .findFirstByReportIdAndStatus(reportId, "ACTIVE")
//                .map(rt -> rt.getTemplateJson())
//                .orElseThrow(() ->
//                        new IllegalStateException("Active template not found for reportId: " + reportId));
//
//        TemplatePayload oldTemplate = parseTemplate(oldTemplateJson, "stored template");

        // Fetch variants for the old template
        List<VariantDto> oldVariants = reportVariantRepository.findByTemplateId(oldEntity.getTemplateId())
                .stream()
                .map(this::mapToVariantDto).toList();

        oldTemplate.setVariants(oldVariants);           // Set variants to the old template

        // 4️⃣ Run diff logic
        // 4a. Compare Cells
        Map<String, Map<String, ValueDiff>> cellDiffs =
                jsonCompareUtil.compareCells(oldTemplate, newTemplate);

        // 4b. Compare Columns
        Map<String, Map<String, ValueDiff>> columnDiffs =
                jsonCompareUtil.compareColumns(oldTemplate, newTemplate);

        // 4c. Compare variants
        Map<String, Map<String, ValueDiff>> variantDiffs =
                jsonCompareUtil.compareVariants(oldTemplate.getVariants(), newTemplate.getVariants());

        // Compare Global Params
        Map<String, Map<String, ValueDiff>> globalParamDiffs = jsonCompareUtil.compareGlobalParams(
                oldTemplate.getTemplate().getGlobalParams(),
                newTemplate.getTemplate().getGlobalParams()
        );

        // 5️⃣ Response
        return TemplateDiffResponseDto.builder()
                .oldTemplate(oldTemplate)
                .newTemplate(newTemplate)
                .cellDiffs(cellDiffs)
                .columnDiffs(columnDiffs) // Add columns to response
                .variantDiffs(variantDiffs)
                .globalParamDiffs(globalParamDiffs)
                .build();
    }

    // Helper to map ReportVariant entity to VariantDto
    private VariantDto mapToVariantDto(ReportVariant entity){
        return VariantDto.builder()
                .variantCode(entity.getVariantCode())
                .variantName(entity.getVariantName())
                .description(entity.getDescription())
                .status(entity.getStatus())
                .params(entity.getParams() != null ? entity.getParams().stream()
                        .map(def -> VariantParamDto.builder()
                                .paramName(def.getParamName())
                                .label(def.getLabel())
                                .paramType(def.getParamType())
                                .validation(def.getValidation())
                                .uiHint(def.getUiHint())
                                .required("Y".equalsIgnoreCase(def.getRequired()))
                                .multiValued("Y".equalsIgnoreCase(def.getMultiVal())).build())
                        .toList() : new ArrayList<>())
                .filterRules(entity.getFilterRules() != null ? entity.getFilterRules().stream()
                        .map(rule -> FilterRuleDto.builder()
                                .dbColumn(rule.getDbColumn())
                                .operator(rule.getOperator())
                                .paramName(rule.getParamName())
                                .scopeType(rule.getScopeType())
                                .scopeValue(rule.getScopeValue())
                                .build())
                        .toList() : new ArrayList<>())
                .build();
    }

    private TemplatePayload parseTemplate(String json, String source) {
        try {
            TemplatePayload dto = objectMapper.readValue(json, TemplatePayload.class);
            if (dto.getTemplate() != null) {
                return dto;
            }

            // Fallback: wrap flat JSON into Template structure
            Map<String, Object> raw = objectMapper.readValue(json, Map.class);
            TemplatePayload.Template template = TemplatePayload.Template.builder()
                    .templateMeta(objectMapper.convertValue(raw.get("templateMeta"), TemplatePayload.TemplateMeta.class))
                    .reportMeta(objectMapper.convertValue(raw.get("reportMeta"), TemplatePayload.ReportMeta.class))
                    .reportData(objectMapper.convertValue(raw.get("reportData"), TemplatePayload.ReportData.class))
                    .build();

            return TemplatePayload.builder()
                    .template(template)
                    .variants(List.of())
                    .build();
        } catch (Exception e) {
            throw new IllegalStateException("Invalid " + source + " JSON", e);
        }
    }
}






// ===============================================================================================================================================================================================================================================
// util/JsonCompareUtil.java
// ===============================================================================================================================================================================================================================================


package com.fincore.TemplateConfigurationService.util;

import com.fincore.TemplateConfigurationService.dto.TemplatePayload;
import com.fincore.TemplateConfigurationService.dto.ValueDiff;
import com.fincore.TemplateConfigurationService.dto.VariantDto;
import org.springframework.stereotype.Component;

import java.util.*;

@Component
public class JsonCompareUtil {

    /**
     * Compare Rows and Cells
     */
    public Map<String, Map<String, ValueDiff>> compareCells(
            TemplatePayload oldTemplate,
            TemplatePayload newTemplate
    ) {
        Map<String, Map<String, ValueDiff>> diffs = new LinkedHashMap<>();

        List<TemplatePayload.Row> oldRows = getRowsSafe(oldTemplate);
        List<TemplatePayload.Row> newRows = getRowsSafe(newTemplate);

        int maxRows = Math.max(oldRows.size(), newRows.size());

        for (int r = 0; r < maxRows; r++) {
            TemplatePayload.Row oldRow = r < oldRows.size() ? oldRows.get(r) : null;
            TemplatePayload.Row newRow = r < newRows.size() ? newRows.get(r) : null;

            // If a row is completely missing or added, you might handle it here.
            // For now, we proceed to check cells if both rows exist (or partially exist)
            List<TemplatePayload.Cell> oldCells = (oldRow != null) ? oldRow.getCells() : Collections.emptyList();
            List<TemplatePayload.Cell> newCells = (newRow != null) ? newRow.getCells() : Collections.emptyList();

            int maxCells = Math.max(oldCells.size(), newCells.size());

            for (int c = 0; c < maxCells; c++) {
                TemplatePayload.Cell oldCell = c < oldCells.size() ? oldCells.get(c) : null;
                TemplatePayload.Cell newCell = c < newCells.size() ? newCells.get(c) : null;

                if (oldCell == null && newCell == null) continue;

                String cellKey = buildCellKey(oldCell, newCell, r, c);
                Map<String, ValueDiff> fieldDiffs = compareCellFields(oldCell, newCell);

                if (!fieldDiffs.isEmpty()) {
                    diffs.put(cellKey, fieldDiffs);
                }
            }
        }
        return diffs;
    }

    /**
     * Compare Column Definitions
     */
    public Map<String, Map<String, ValueDiff>> compareColumns(
            TemplatePayload oldTemplate,
            TemplatePayload newTemplate
    ) {
        Map<String, Map<String, ValueDiff>> diffs = new LinkedHashMap<>();

        List<TemplatePayload.ColumnDefinition> oldCols = getColumnsSafe(oldTemplate);
        List<TemplatePayload.ColumnDefinition> newCols = getColumnsSafe(newTemplate);

        int maxCols = Math.max(oldCols.size(), newCols.size());

        for (int i = 0; i < maxCols; i++) {
            TemplatePayload.ColumnDefinition oldCol = i < oldCols.size() ? oldCols.get(i) : null;
            TemplatePayload.ColumnDefinition newCol = i < newCols.size() ? newCols.get(i) : null;

            if (oldCol == null && newCol == null) continue;

            // Generate a reliable key for the frontend to identify which column changed
            String colKey = buildColumnKey(oldCol, newCol, i);

            Map<String, ValueDiff> fieldDiffs = compareColumnFields(oldCol, newCol);

            if (!fieldDiffs.isEmpty()) {
                diffs.put(colKey, fieldDiffs);
            }
        }
        return diffs;
    }

    // 3. METHOD: Compare variants
    public Map<String, Map<String, ValueDiff>> compareVariants(
            List<VariantDto> oldVariants,
            List<VariantDto> newVariants
    ) {
        Map<String, Map<String, ValueDiff>> diffs = new LinkedHashMap<>();

        // Use a Set to collect all unique variant codes from both lists
        Set<String> allCodes = new LinkedHashSet<>();
        if (oldVariants != null) oldVariants.forEach(v -> allCodes.add(v.getVariantCode()));
        if (newVariants != null) newVariants.forEach(v -> allCodes.add(v.getVariantCode()));

        for (String code : allCodes) {
            VariantDto oldV = findVariantByCode(oldVariants, code);
            VariantDto newV = findVariantByCode(newVariants, code);

            Map<String, ValueDiff> fieldDiffs = new LinkedHashMap<>();

            // 1. Compare basic fields
            compareField("variantName",
                    oldV != null ? oldV.getVariantName() : null,
                    newV != null ? newV.getVariantName() : null, fieldDiffs);

            compareField("description",
                    oldV != null ? oldV.getDescription() : null,
                    newV != null ? newV.getDescription() : null, fieldDiffs);

            compareField("status",
                    oldV != null ? oldV.getStatus() : null,
                    newV != null ? newV.getStatus() : null, fieldDiffs);

            // 2. Compare complex lists (Params and Filter Rules)
            compareField("params",
                    oldV != null ? oldV.getParams() : null,
                    newV != null ? newV.getParams() : null, fieldDiffs);

            compareField("filterRules",
                    oldV != null ? oldV.getFilterRules() : null,
                    newV != null ? newV.getFilterRules() : null, fieldDiffs);

            if (!fieldDiffs.isEmpty()) {
                diffs.put(code, fieldDiffs);
            }
        }
        return diffs;
    }


    // 4. METHOD: Compare Global Params
    public Map<String, Map<String, ValueDiff>> compareGlobalParams(
            List<TemplatePayload.GlobalParamDef> oldParams,
            List<TemplatePayload.GlobalParamDef> newParams
    ) {
        Map<String, Map<String, ValueDiff>> diffs = new LinkedHashMap<>();
        Set<String> allNames = new LinkedHashSet<>();
        if (oldParams != null) oldParams.forEach(p -> allNames.add(p.getName()));
        if (newParams != null) newParams.forEach(p -> allNames.add(p.getName()));

        for (String name : allNames) {
            TemplatePayload.GlobalParamDef oldP = findParam(oldParams, name);
            TemplatePayload.GlobalParamDef newP = findParam(newParams, name);

            Map<String, ValueDiff> fieldDiffs = new LinkedHashMap<>();

            // Compare fields
            compareField("name", oldP != null ? oldP.getName() : null, newP != null ? newP.getName() : null, fieldDiffs);
            compareField("label", oldP != null ? oldP.getLabel() : null, newP != null ? newP.getLabel() : null, fieldDiffs);
            compareField("dataType", oldP != null ? oldP.getDataType() : null, newP != null ? newP.getDataType() : null, fieldDiffs);
            compareField("mode", oldP != null ? oldP.getMode() : null, newP != null ? newP.getMode() : null, fieldDiffs);
            compareField("expression", oldP != null ? oldP.getExpression() : null, newP != null ? newP.getExpression() : null, fieldDiffs);
            compareField("defaultValue", oldP != null ? oldP.getDefaultValue() : null, newP != null ? newP.getDefaultValue() : null, fieldDiffs);
            compareField("source", oldP != null ? oldP.getSource() : null, newP != null ? newP.getSource() : null, fieldDiffs);

            if (!fieldDiffs.isEmpty()) {
                diffs.put(name, fieldDiffs);
            }
        }
        return diffs;
    }

    // Helper to find params in the list
    private TemplatePayload.GlobalParamDef findParam(List<TemplatePayload.GlobalParamDef> list, String name) {
        if (list == null) return null;
        return list.stream().filter(p -> name.equals(p.getName())).findFirst().orElse(null);
    }


    // Helper to find a variant in the list by its code
    private VariantDto findVariantByCode(List<VariantDto> list, String code) {
        if (list == null || code == null) return null;
        return list.stream()
                .filter(v -> code.equals(v.getVariantCode()))
                .findFirst()
                .orElse(null);
    }

    // --------------------------------------------------------
    // Comparison Logic Helpers
    // --------------------------------------------------------

    private Map<String, ValueDiff> compareCellFields(TemplatePayload.Cell oldCell, TemplatePayload.Cell newCell) {
        Map<String, ValueDiff> diffs = new LinkedHashMap<>();

        // Handle nulls (Added/Removed cells)
        if (oldCell == null && newCell != null) {
            // Entire cell is new. We can mark key fields as changed from null -> value
            compareField("value", null, newCell.getValue(), diffs);
            return diffs;
        }
        if (oldCell != null && newCell == null) {
            // Cell removed
            compareField("value", oldCell.getValue(), null, diffs);
            return diffs;
        }

        compareField("type", oldCell.getType(), newCell.getType(), diffs);
        compareField("value", oldCell.getValue(), newCell.getValue(), diffs);
        compareField("expression", oldCell.getExpression(), newCell.getExpression(), diffs);
        compareField("variables", oldCell.getVariables(), newCell.getVariables(), diffs);
        compareField("source", oldCell.getSource(), newCell.getSource(), diffs);
        compareField("render", oldCell.getRender(), newCell.getRender(), diffs);
        return diffs;
    }

    private Map<String, ValueDiff> compareColumnFields(TemplatePayload.ColumnDefinition oldCol, TemplatePayload.ColumnDefinition newCol) {
        Map<String, ValueDiff> diffs = new LinkedHashMap<>();

        if (oldCol == null && newCol != null) {
            compareField("name", null, newCol.getName(), diffs);
            return diffs;
        }
        if (oldCol != null && newCol == null) {
            compareField("name", oldCol.getName(), null, diffs);
            return diffs;
        }

        assert oldCol != null;
        compareField("id", oldCol.getId(), newCol.getId(), diffs);
        compareField("name", oldCol.getName(), newCol.getName(), diffs);
        compareField("format", oldCol.getFormat(), newCol.getFormat(), diffs);
        compareField("filters",
                oldCol.getTemplateColumnFilters(),
                newCol.getTemplateColumnFilters(),
                diffs);

        return diffs;
    }

    private void compareField(String field, Object oldVal, Object newVal, Map<String, ValueDiff> diffs) {
        if (!Objects.equals(oldVal, newVal)) {
            diffs.put(field, new ValueDiff(oldVal, newVal));
        }
    }

    // --------------------------------------------------------
    // Key Generation Helpers
    // --------------------------------------------------------

    private String buildCellKey(TemplatePayload.Cell oldCell, TemplatePayload.Cell newCell, int r, int c) {
        if (newCell != null && newCell.getId() != null) return newCell.getId();
        if (oldCell != null && oldCell.getId() != null) return oldCell.getId();
        // Deterministic fallback
        return "R" + r + "C" + c;
    }

    private String buildColumnKey(TemplatePayload.ColumnDefinition oldCol, TemplatePayload.ColumnDefinition newCol, int index) {
        if (newCol != null && newCol.getId() != null) return newCol.getId();
        if (oldCol != null && oldCol.getId() != null) return oldCol.getId();
        // Deterministic fallback
        return "C" + index;
    }

    // --------------------------------------------------------
    // Null-Safe Accessors
    // --------------------------------------------------------

    private List<TemplatePayload.Row> getRowsSafe(TemplatePayload t) {
        if (t == null || t.getTemplate() == null
                || t.getTemplate().getReportData() == null
                || t.getTemplate().getReportData().getRows() == null) {
            return Collections.emptyList();
        }
        return t.getTemplate().getReportData().getRows();
    }

    private List<TemplatePayload.ColumnDefinition> getColumnsSafe(TemplatePayload t) {
        if (t == null || t.getTemplate() == null
                || t.getTemplate().getReportData() == null
                || t.getTemplate().getReportData().getColumns() == null) {
            return Collections.emptyList();
        }
        return t.getTemplate().getReportData().getColumns();
    }
}



