// =====================================================================================
// dto/ValueDiff.java
// ==========≈==========================================================================

package com.fincore.TemplateConfigurationService.dto;

import lombok.*;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ValueDiff {
    private Object oldValue;
    private Object newValue;
}



// =====================================================================================
// dto/TemplatePayload.java
// ==========≈==========================================================================



package com.fincore.TemplateConfigurationService.dto;

import jakarta.validation.constraints.NotNull;
import lombok.*;

import javax.swing.*;
import java.util.List;
import java.util.Map;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TemplatePayload{

    @NotNull
    private Template template;

    @NotNull
    private List<VariantDto> variants;

    @Getter
    @Setter
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class Template {
        @NotNull
        private TemplateMeta templateMeta;

        @NotNull
        private ReportMeta reportMeta;

        @NotNull
        private ReportData reportData;
    }

    @Getter
    @Setter
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class TemplateMeta {
        private String templateId;
        private String version;
        private String description;
        // e.g. "A4", "LETTER"; "portrait" / "landscape"
        private String pageSize;
        private String pageOrientation;
        private String headerLayout;  //layout (1-col, 2-col, etc.)
    }

    @Data
    public static class ReportMeta {
        private String reportName;
        private String reportId;
        private List<Map<String, String>> extras;
    }

    @Data
    public static class ReportData {
        private List<ColumnDefinition> columns;
        private List<Row> rows;
    }

    @Data
    public static class ColumnDefinition {
        private String id;
        private String name;
        private Map<String, Object> format; // flexible formatting map
    }

    @Data
    public static class Row {
        /**
         * DATA|GROUP_START|GROUP_END|NOTE|BREAK|DYNAMIC (future)
         */
        private String id;
        private String rowType;
        private String rowTitle;
        private List<Cell> cells;

        // Extension point for dynamic blocks etc.
        // Example: { "type":"DB_LIST", "table":"...", "filters":{...}, "limit":100 }
        private Map<String, Object> dynamicConfig;
    }

    @Data
    public static class Cell {
        private String id;                     // assigned by TemplateProcessor (R{row}C{col})
        private String type;                   // TEXT, DB_*, FORMULA, etc.
        private Object value;                  // used for TEXT cells
        private String expression;             // used for formulas
        private Map<String, Object> variables; // formula vars (CELL_REF, DB_*, CONST, etc.)
        private Map<String, Object> source;    // for DB_* types: { table, column, filters }
        private Map<String, Object> render;    // { bold, colspan, rowspan, align, format, bgColor, ... }
    }


}







// =====================================================================================
// dto/TemplateDiffResponseDto.java
// ==========≈==========================================================================


package com.fincore.TemplateConfigurationService.dto;

import lombok.*;

import java.util.Map;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TemplateDiffResponseDto {

    private TemplatePayload oldTemplate;
    private TemplatePayload newTemplate;

    /**
     * cellId -> (fieldName -> old/new value)
     */
    private Map<String, Map<String, ValueDiff>> cellDiffs;

    /**
     * cellId -> (fieldName -> old/new value)
     */
    private Map<String, Map<String, ValueDiff>> columnDiffs;
}




// =====================================================================================
// controller 
// ==========≈==========================================================================


    package com.fincore.TemplateConfigurationService.controller;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fincore.TemplateConfigurationService.dto.*;
import com.fincore.TemplateConfigurationService.entity.ReportTemplate;
import com.fincore.TemplateConfigurationService.service.AllowedTableService;
import com.fincore.TemplateConfigurationService.service.TemplateDiffService;
import com.fincore.TemplateConfigurationService.service.TemplateService;
import com.fincore.TemplateConfigurationService.constants.ResponseMessages;
import com.fincore.TemplateConfigurationService.response.ApiResponse;
import com.fincore.commonutilities.jwt.JwtUtil;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;

@Slf4j
@RestController
@RequestMapping("/api")
@RequiredArgsConstructor
public class TemplateController {

    private final TemplateService templateService;
    private final TemplateDiffService templateDiffService;
    private final JwtUtil jwtUtil;

    @Autowired
    private AllowedTableService tableService;

    @GetMapping("/allowed-tables")
    public  ResponseEntity<List<AllowedTablesDTO>> getAllTables(){
        return ResponseEntity.ok(tableService.getTableWithColumnsAll());
    }

    @GetMapping("/{tableId}")
    public ResponseEntity<AllowedTablesDTO> getAllowedTables(@PathVariable Long tableId) {
        return ResponseEntity.ok(tableService.getTableWithColumns(tableId));
    }

    // -------------------------------------------------
    // CREATE / UPDATE TEMPLATE
    // -------------------------------------------------
    @PostMapping("/save")
    public ResponseEntity<ApiResponse> saveTemplate(
            @Valid @RequestBody TemplatePayload payload,
            @RequestHeader("Authorization") String token,
            HttpServletRequest request) {

        String userId = jwtUtil.getUserIdFromToken(token);

        log.info("API: Save Template called by {}", userId);

        ReportTemplate saved = templateService.createOrUpdateTemplate(payload, userId);

        ApiResponse response = ApiResponse.builder()
                .message(ResponseMessages.TEMPLATE_SAVED)
                .status("SUCCESS")
                .data(saved.getTemplateId())
                .timestamp(LocalDateTime.now())
                .path(request.getRequestURI())
                .build();

        return ResponseEntity.ok(response);
    }

    // -------------------------------------------------
    // GET TEMPLATE WITH VARIANTS
    // -------------------------------------------------
    @GetMapping("/getTemplate/{templateId}")
    public ResponseEntity<ApiResponse> getTemplate(
            @PathVariable String templateId,
            HttpServletRequest request) {

        log.info("API: Get Template {}", templateId);

        TemplateResponse payload = null;
        try {
            payload = templateService.getTemplateWithVariants(templateId);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }

        ApiResponse response = ApiResponse.builder()
                .message(ResponseMessages.TEMPLATE_FETCHED)
                .status("SUCCESS")
                .data(payload)
                .timestamp(LocalDateTime.now())
                .path(request.getRequestURI())
                .build();

        return ResponseEntity.ok(response);
    }

    // -------------------------------------------------
    // GET ALL TEMPLATES
    // -------------------------------------------------
    @GetMapping("/get-templates")
    public ResponseEntity<ApiResponse> getALLTemplates(HttpServletRequest request) {

        List<TemplateResponse> templates = templateService.getAllTemplates();

        ApiResponse response = ApiResponse.builder()
                .message(ResponseMessages.ALL_TEMPLATES_FETCHED)
                .status("SUCCESS")
                .data(templates)
                .timestamp(LocalDateTime.now())
                .path(request.getRequestURI())
                .build();

        return ResponseEntity.ok(response);
    }

    // -------------------------------------------------
    // DELETE TEMPLATE
    // -------------------------------------------------
    @DeleteMapping("/{templateId}")
    public ResponseEntity<ApiResponse> deleteTemplate(
            @PathVariable String templateId,
            HttpServletRequest request) {

        templateService.deleteTemplate(templateId);

        ApiResponse response = ApiResponse.builder()
                .message(ResponseMessages.TEMPLATE_DELETED)
                .status("SUCCESS")
                .timestamp(LocalDateTime.now())
                .path(request.getRequestURI())
                .build();

        return ResponseEntity.ok(response);
    }

    // ---------------------------------------------------
    // UPDATE STATUS
    // ---------------------------------------------------
    @PatchMapping("/status/{templateId}")
    public ResponseEntity<ApiResponse> updateTemplateStatus(
            @PathVariable String templateId,
            @RequestBody @Valid TemplateStatusRequest request,
            @RequestHeader("Authorization") String token
    ){
        String userId = jwtUtil.getUserIdFromToken(token);
        templateService.updateStatus(templateId, request.getStatus(), userId);
        ApiResponse response  = ApiResponse.builder()
                .message("Status updated successfully.")
                .status("SUCCESS")
                .timestamp(LocalDateTime.now())
                .build();
        return ResponseEntity.ok(response);
    }


    @PostMapping("/template-diff")
    public TemplateDiffResponseDto compareTemplates(
            @RequestBody TemplateDiffRequest request
    ) {
        log.info("Display the CompareTemplate dialog box {}", request.getRequestId());
        return templateDiffService.compareByRequestId(request.getRequestId());
    }

    @Data
    public static class TemplateDiffRequest {
        private Long requestId;
    }

}






// =====================================================================================
// service/TemplateDiffService.java
// ==========≈==========================================================================



package com.fincore.TemplateConfigurationService.service;

import com.fincore.TemplateConfigurationService.dto.TemplateDiffResponseDto;

public interface TemplateDiffService {

    TemplateDiffResponseDto compareByRequestId(Long requestId);
}







// =====================================================================================
// service/TemplateDiffServiceImpl.java
// ==========≈==========================================================================



package com.fincore.TemplateConfigurationService.service.impl;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fincore.TemplateConfigurationService.dto.*;
import com.fincore.TemplateConfigurationService.entity.CommonReq;
import com.fincore.TemplateConfigurationService.repository.CommonRequestRepository;
import com.fincore.TemplateConfigurationService.repository.ReportTemplateRepository;
import com.fincore.TemplateConfigurationService.service.TemplateDiffService;
import com.fincore.TemplateConfigurationService.util.JsonCompareUtil;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;

@Service
@RequiredArgsConstructor
public class TemplateDiffServiceImpl implements TemplateDiffService {

    private final CommonRequestRepository commonRequestRepository;
    private final ReportTemplateRepository reportTemplateRepository;
    private final JsonCompareUtil jsonCompareUtil;
    private final ObjectMapper objectMapper;

    @Override
    public TemplateDiffResponseDto compareByRequestId(Long requestId) {

        // 1️⃣ Fetch NEW template from request payload
        CommonReq req = commonRequestRepository.findById(requestId)
                .orElseThrow(() ->
                        new IllegalArgumentException("Request not found: " + requestId));

        TemplatePayload newTemplate = parseTemplate(req.getPayload(), "request payload");

        // 2️⃣ Extract reportId safely
        String reportId = newTemplate.getTemplate()
                .getReportMeta()
                .getReportId();

        // 3️⃣ Fetch OLD ACTIVE template JSON from DB
        String oldTemplateJson = reportTemplateRepository
                .findFirstByReportIdAndStatus(reportId, "ACTIVE")
                .map(rt -> rt.getTemplateJson())
                .orElseThrow(() ->
                        new IllegalStateException("Active template not found for reportId: " + reportId));

        TemplatePayload oldTemplate = parseTemplate(oldTemplateJson, "stored template");

        // 4️⃣ Run diff logic
        // 4a. Compare Cells
        Map<String, Map<String, ValueDiff>> cellDiffs =
                jsonCompareUtil.compareCells(oldTemplate, newTemplate);

        // 4b. Compare Columns (NEW LOGIC)
        Map<String, Map<String, ValueDiff>> columnDiffs =
                jsonCompareUtil.compareColumns(oldTemplate, newTemplate);

        // 5️⃣ Response
        return TemplateDiffResponseDto.builder()
                .oldTemplate(oldTemplate)
                .newTemplate(newTemplate)
                .cellDiffs(cellDiffs)
                .columnDiffs(columnDiffs) // Add columns to response
                .build();
    }

    private TemplatePayload parseTemplate(String json, String source) {
        try {
            TemplatePayload dto = objectMapper.readValue(json, TemplatePayload.class);
            if (dto.getTemplate() != null) {
                return dto;
            }

            // Fallback: wrap flat JSON into Template structure
            Map<String, Object> raw = objectMapper.readValue(json, Map.class);
            TemplatePayload.Template template = TemplatePayload.Template.builder()
                    .templateMeta(objectMapper.convertValue(raw.get("templateMeta"), TemplatePayload.TemplateMeta.class))
                    .reportMeta(objectMapper.convertValue(raw.get("reportMeta"), TemplatePayload.ReportMeta.class))
                    .reportData(objectMapper.convertValue(raw.get("reportData"), TemplatePayload.ReportData.class))
                    .build();

            return TemplatePayload.builder()
                    .template(template)
                    .variants(List.of())
                    .build();
        } catch (Exception e) {
            throw new IllegalStateException("Invalid " + source + " JSON", e);
        }
    }
}





// =====================================================================================
// util/JsonCompareUtil.java
// ==========≈==========================================================================

package com.fincore.TemplateConfigurationService.util;

import com.fincore.TemplateConfigurationService.dto.TemplatePayload;
import com.fincore.TemplateConfigurationService.dto.ValueDiff;
import org.springframework.stereotype.Component;

import java.util.*;

@Component
public class JsonCompareUtil {

    /**
     * Compare Rows and Cells
     */
    public Map<String, Map<String, ValueDiff>> compareCells(
            TemplatePayload oldTemplate,
            TemplatePayload newTemplate
    ) {
        Map<String, Map<String, ValueDiff>> diffs = new LinkedHashMap<>();

        List<TemplatePayload.Row> oldRows = getRowsSafe(oldTemplate);
        List<TemplatePayload.Row> newRows = getRowsSafe(newTemplate);

        int maxRows = Math.max(oldRows.size(), newRows.size());

        for (int r = 0; r < maxRows; r++) {
            TemplatePayload.Row oldRow = r < oldRows.size() ? oldRows.get(r) : null;
            TemplatePayload.Row newRow = r < newRows.size() ? newRows.get(r) : null;

            // If a row is completely missing or added, you might handle it here.
            // For now, we proceed to check cells if both rows exist (or partially exist)
            List<TemplatePayload.Cell> oldCells = (oldRow != null) ? oldRow.getCells() : Collections.emptyList();
            List<TemplatePayload.Cell> newCells = (newRow != null) ? newRow.getCells() : Collections.emptyList();

            int maxCells = Math.max(oldCells.size(), newCells.size());

            for (int c = 0; c < maxCells; c++) {
                TemplatePayload.Cell oldCell = c < oldCells.size() ? oldCells.get(c) : null;
                TemplatePayload.Cell newCell = c < newCells.size() ? newCells.get(c) : null;

                if (oldCell == null && newCell == null) continue;

                String cellKey = buildCellKey(oldCell, newCell, r, c);
                Map<String, ValueDiff> fieldDiffs = compareCellFields(oldCell, newCell);

                if (!fieldDiffs.isEmpty()) {
                    diffs.put(cellKey, fieldDiffs);
                }
            }
        }
        return diffs;
    }

    /**
     * Compare Column Definitions
     */
    public Map<String, Map<String, ValueDiff>> compareColumns(
            TemplatePayload oldTemplate,
            TemplatePayload newTemplate
    ) {
        Map<String, Map<String, ValueDiff>> diffs = new LinkedHashMap<>();

        List<TemplatePayload.ColumnDefinition> oldCols = getColumnsSafe(oldTemplate);
        List<TemplatePayload.ColumnDefinition> newCols = getColumnsSafe(newTemplate);

        int maxCols = Math.max(oldCols.size(), newCols.size());

        for (int i = 0; i < maxCols; i++) {
            TemplatePayload.ColumnDefinition oldCol = i < oldCols.size() ? oldCols.get(i) : null;
            TemplatePayload.ColumnDefinition newCol = i < newCols.size() ? newCols.get(i) : null;

            if (oldCol == null && newCol == null) continue;

            // Generate a reliable key for the frontend to identify which column changed
            String colKey = buildColumnKey(oldCol, newCol, i);

            Map<String, ValueDiff> fieldDiffs = compareColumnFields(oldCol, newCol);

            if (!fieldDiffs.isEmpty()) {
                diffs.put(colKey, fieldDiffs);
            }
        }
        return diffs;
    }

    // --------------------------------------------------------
    // Comparison Logic Helpers
    // --------------------------------------------------------

    private Map<String, ValueDiff> compareCellFields(TemplatePayload.Cell oldCell, TemplatePayload.Cell newCell) {
        Map<String, ValueDiff> diffs = new LinkedHashMap<>();

        // Handle nulls (Added/Removed cells)
        if (oldCell == null && newCell != null) {
            // Entire cell is new. We can mark key fields as changed from null -> value
            compareField("value", null, newCell.getValue(), diffs);
            return diffs;
        }
        if (oldCell != null && newCell == null) {
            // Cell removed
            compareField("value", oldCell.getValue(), null, diffs);
            return diffs;
        }

        compareField("type", oldCell.getType(), newCell.getType(), diffs);
        compareField("value", oldCell.getValue(), newCell.getValue(), diffs);
        compareField("expression", oldCell.getExpression(), newCell.getExpression(), diffs);
        compareField("variables", oldCell.getVariables(), newCell.getVariables(), diffs);
        compareField("source", oldCell.getSource(), newCell.getSource(), diffs);
        compareField("render", oldCell.getRender(), newCell.getRender(), diffs);
        return diffs;
    }

    private Map<String, ValueDiff> compareColumnFields(TemplatePayload.ColumnDefinition oldCol, TemplatePayload.ColumnDefinition newCol) {
        Map<String, ValueDiff> diffs = new LinkedHashMap<>();

        if (oldCol == null && newCol != null) {
            compareField("name", null, newCol.getName(), diffs);
            return diffs;
        }
        if (oldCol != null && newCol == null) {
            compareField("name", oldCol.getName(), null, diffs);
            return diffs;
        }

        compareField("id", oldCol.getId(), newCol.getId(), diffs);
        compareField("name", oldCol.getName(), newCol.getName(), diffs);
        compareField("format", oldCol.getFormat(), newCol.getFormat(), diffs);

        return diffs;
    }

    private void compareField(String field, Object oldVal, Object newVal, Map<String, ValueDiff> diffs) {
        if (!Objects.equals(oldVal, newVal)) {
            diffs.put(field, new ValueDiff(oldVal, newVal));
        }
    }

    // --------------------------------------------------------
    // Key Generation Helpers
    // --------------------------------------------------------

    private String buildCellKey(TemplatePayload.Cell oldCell, TemplatePayload.Cell newCell, int r, int c) {
        if (newCell != null && newCell.getId() != null) return newCell.getId();
        if (oldCell != null && oldCell.getId() != null) return oldCell.getId();
        // Deterministic fallback
        return "R" + r + "C" + c;
    }

    private String buildColumnKey(TemplatePayload.ColumnDefinition oldCol, TemplatePayload.ColumnDefinition newCol, int index) {
        if (newCol != null && newCol.getId() != null) return newCol.getId();
        if (oldCol != null && oldCol.getId() != null) return oldCol.getId();
        // Deterministic fallback
        return "C" + index;
    }

    // --------------------------------------------------------
    // Null-Safe Accessors
    // --------------------------------------------------------

    private List<TemplatePayload.Row> getRowsSafe(TemplatePayload t) {
        if (t == null || t.getTemplate() == null
                || t.getTemplate().getReportData() == null
                || t.getTemplate().getReportData().getRows() == null) {
            return Collections.emptyList();
        }
        return t.getTemplate().getReportData().getRows();
    }

    private List<TemplatePayload.ColumnDefinition> getColumnsSafe(TemplatePayload t) {
        if (t == null || t.getTemplate() == null
                || t.getTemplate().getReportData() == null
                || t.getTemplate().getReportData().getColumns() == null) {
            return Collections.emptyList();
        }
        return t.getTemplate().getReportData().getColumns();
    }
}


