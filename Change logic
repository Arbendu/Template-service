
////////////////////////////////////////////////////////////////////////////////
service/diff/IdentityResolver.java
//////////////////////////////////////////////////////////////////////

package com.tcs.fincore.CommonRequestService.service.diff;

import java.util.Map;

public class IdentityResolver {

    public static String resolveVariant(Map<String, Object> v) {
        return (String) v.get("variantCode");
    }

    public static String resolveRow(Map<String, Object> r) {
        return (String) r.get("rowCode");
    }

    public static String resolveColumn(Map<String, Object> c) {
        return (String) c.get("columnCode");
    }

    public static String resolveParam(Map<String, Object> p) {
        return (String) p.get("paramName");
    }

    public static String resolveFilter(Map<String, Object> f) {
        return f.get("column") + "|" + f.get("operator") + "|" + f.get("value");
    }
}






==================================================================
service/diff/ContentHasher.java
======================================â‰ˆâ‰ˆ==========================

package com.tcs.fincore.CommonRequestService.service.diff;

import com.fasterxml.jackson.databind.ObjectMapper;

import java.security.MessageDigest;

public class ContentHasher {

    private static final ObjectMapper mapper = new ObjectMapper();

    public static String hash(Object obj) {
        try {
            byte[] json = mapper.writeValueAsBytes(obj);
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            byte[] digest = md.digest(json);

            StringBuilder sb = new StringBuilder();
            for (byte b : digest) sb.append(String.format("%02x", b));
            return sb.toString();

        } catch (Exception e) {
            throw new RuntimeException("Hashing failed", e);
        }
    }
}







====================================================================
service/diff/TemplateDiffEngine.java
====================================================================

package com.tcs.fincore.CommonRequestService.service.diff;

import com.tcs.fincore.CommonRequestService.dto.diff.FieldDiffDto;
import com.tcs.fincore.CommonRequestService.model.enums.DiffType;

import java.util.*;

public class TemplateDiffEngine {

    public List<FieldDiffDto> diffObjects(
            String basePath,
            Map<String, Object> oldObj,
            Map<String, Object> newObj
    ) {
        List<FieldDiffDto> diffs = new ArrayList<>();

        Set<String> keys = new HashSet<>();
        if (oldObj != null) keys.addAll(oldObj.keySet());
        if (newObj != null) keys.addAll(newObj.keySet());

        for (String key : keys) {
            Object o = oldObj != null ? oldObj.get(key) : null;
            Object n = newObj != null ? newObj.get(key) : null;

            DiffType type;
            if (o == null && n != null) type = DiffType.ADDED;
            else if (o != null && n == null) type = DiffType.REMOVED;
            else if (!Objects.equals(o, n)) type = DiffType.MODIFIED;
            else type = DiffType.UNCHANGED;

            diffs.add(FieldDiffDto.builder()
                    .fieldPath(basePath + "." + key)
                    .oldValue(o)
                    .newValue(n)
                    .diffType(type)
                    .build());
        }

        return diffs;
    }
}








===============================================================================
service/diff/TemplateDiffService.java
============================â‰ˆ===============================================

package com.tcs.fincore.CommonRequestService.service.diff;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.tcs.fincore.CommonRequestService.dto.diff.SectionDiffDto;
import com.tcs.fincore.CommonRequestService.dto.diff.TemplateDiffResponseDto;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;

@Service
@RequiredArgsConstructor
public class TemplateDiffService {

    private final ObjectMapper objectMapper;

    // âœ… keep engine as-is (no change in logic)
    private final TemplateDiffEngine engine = new TemplateDiffEngine();

    /**
     * Compare old and new template JSON and return diff
     */
    public TemplateDiffResponseDto diff(String oldJson, String newJson) {

        // âœ… ADD: defensive validation
        if (oldJson == null || oldJson.isBlank()) {
            throw new IllegalArgumentException("oldPayload cannot be null or empty");
        }

        if (newJson == null || newJson.isBlank()) {
            throw new IllegalArgumentException("newPayload cannot be null or empty");
        }

        try {
            // âœ… SAFE JSON parsing
            Map<String, Object> oldTemplate =
                    objectMapper.readValue(oldJson, Map.class);

            Map<String, Object> newTemplate =
                    objectMapper.readValue(newJson, Map.class);

            SectionDiffDto templateSection = SectionDiffDto.builder()
                    .section("TEMPLATE_META")
                    .identifier(null)
                    .fields(engine.diffObjects("template", oldTemplate, newTemplate))
                    .build();

            return TemplateDiffResponseDto.builder()
                    .sections(List.of(templateSection))
                    .build();

        } catch (Exception e) {
            // âœ… Wrap parsing errors with a meaningful message
            throw new IllegalArgumentException("Invalid JSON payload for template diff", e);
        }
    }
}




// =================================================================================
// Rest Controller
// =================================================================================


@PostMapping("/template/diff")
public ApiResponse<?> diff(@RequestBody Map<String, Object> body) {

    String requestType = (String) body.get("requestType");
    String changeType  = (String) body.get("changeType");
    String oldPayload  = (String) body.get("oldPayload");
    String newPayload  = (String) body.get("newPayload");

    // ðŸ”’ HARD VALIDATION (IMPORTANT)
    if (!"UPDATE".equals(changeType)) {
        throw new IllegalArgumentException("Diff is supported only for UPDATE changeType");
    }

    if (oldPayload == null || oldPayload.isBlank()) {
        throw new IllegalArgumentException("oldPayload must not be null or empty");
    }

    if (newPayload == null || newPayload.isBlank()) {
        throw new IllegalArgumentException("newPayload must not be null or empty");
    }

    return ApiResponse.success(
        templateDiffService.diff(oldPayload, newPayload)
    );
}





